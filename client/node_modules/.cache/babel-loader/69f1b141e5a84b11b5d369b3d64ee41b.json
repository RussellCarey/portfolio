{"ast":null,"code":"import _asyncToGenerator from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _construct from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _createClass from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _toConsumableArray from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectWithoutProperties from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"predicates\"],\n    _excluded2 = [\"limit\"],\n    _excluded3 = [\"signal\"];\nimport _regeneratorRuntime from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/regenerator/index.js\";\nimport * as prismicH from '@prismicio/helpers';\n\nvar getEndpoint = function getEndpoint(repositoryName) {\n  return \"https://\".concat(repositoryName, \".cdn.prismic.io/api/v2\");\n};\n\nvar getGraphQLEndpoint = function getGraphQLEndpoint(repositoryName) {\n  return \"https://\".concat(repositoryName, \".cdn.prismic.io/graphql\");\n};\n\nvar castArray = function castArray(a) {\n  return Array.isArray(a) ? a : [a];\n};\n\nvar RENAMED_PARAMS = {\n  accessToken: \"access_token\"\n};\n\nvar castOrderingToString = function castOrderingToString(ordering) {\n  return typeof ordering === \"string\" ? ordering : [ordering.field, ordering.direction === \"desc\" ? ordering.direction : void 0].filter(Boolean).join(\" \");\n};\n\nvar _buildQueryURL = function buildQueryURL(endpoint, args) {\n  var _a;\n\n  var predicates = args.predicates,\n      params = _objectWithoutProperties(args, _excluded);\n\n  var url = new URL(\"documents/search\", \"\".concat(endpoint, \"/\"));\n\n  if (predicates) {\n    var _iterator = _createForOfIteratorHelper(castArray(predicates)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _predicate = _step.value;\n        url.searchParams.append(\"q\", \"[\".concat(_predicate, \"]\"));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  for (var k in params) {\n    var name = (_a = RENAMED_PARAMS[k]) != null ? _a : k;\n    var value = params[k];\n\n    if (name === \"orderings\") {\n      var scopedValue = params[name];\n\n      if (scopedValue != null) {\n        var v = castArray(scopedValue).map(function (ordering) {\n          return castOrderingToString(ordering);\n        }).join(\",\");\n        value = \"[\".concat(v, \"]\");\n      }\n    } else if (name === \"routes\") {\n      if (typeof params[name] === \"object\") {\n        value = JSON.stringify(castArray(params[name]));\n      }\n    }\n\n    if (value != null) {\n      url.searchParams.set(name, castArray(value).join(\",\"));\n    }\n  }\n\n  return url.toString();\n};\n\nvar appendPredicates = function appendPredicates() {\n  var objWithPredicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var predicates = arguments.length > 1 ? arguments[1] : undefined;\n  return _objectSpread(_objectSpread({}, objWithPredicates), {}, {\n    predicates: [].concat(_toConsumableArray(objWithPredicates.predicates || []), _toConsumableArray(castArray(predicates)))\n  });\n};\n\nvar castThunk = function castThunk(a) {\n  return typeof a === \"function\" ? a : function () {\n    return a;\n  };\n};\n\nvar PrismicError = /*#__PURE__*/function (_Error) {\n  _inherits(PrismicError, _Error);\n\n  var _super = _createSuper(PrismicError);\n\n  function PrismicError() {\n    var _this;\n\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"An invalid API response was returned\";\n    var url = arguments.length > 1 ? arguments[1] : undefined;\n    var response = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, PrismicError);\n\n    _this = _super.call(this, message);\n    _this.url = url;\n    _this.response = response;\n    return _this;\n  }\n\n  return _createClass(PrismicError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar findRef = function findRef(refs, predicate) {\n  var ref = refs.find(function (ref2) {\n    return predicate(ref2);\n  });\n\n  if (!ref) {\n    throw new PrismicError(\"Ref could not be found.\", void 0, void 0);\n  }\n\n  return ref;\n};\n\nvar findMasterRef = function findMasterRef(refs) {\n  return findRef(refs, function (ref) {\n    return ref.isMasterRef;\n  });\n};\n\nvar findRefByID = function findRefByID(refs, id) {\n  return findRef(refs, function (ref) {\n    return ref.id === id;\n  });\n};\n\nvar findRefByLabel = function findRefByLabel(refs, label) {\n  return findRef(refs, function (ref) {\n    return ref.label === label;\n  });\n};\n\nvar readValue = function readValue(value) {\n  return value.replace(/%3B/g, \";\");\n};\n\nvar parse = function parse(cookieString) {\n  var result = {};\n  var cookies = cookieString.split(\"; \");\n\n  var _iterator2 = _createForOfIteratorHelper(cookies),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _cookie = _step2.value;\n\n      var parts = _cookie.split(\"=\");\n\n      var value = parts.slice(1).join(\"=\");\n      var name = readValue(parts[0]).replace(/%3D/g, \"=\");\n      result[name] = readValue(value);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n};\n\nvar getAll = function getAll(cookieStore) {\n  return parse(cookieStore);\n};\n\nvar getCookie = function getCookie(name, cookieStore) {\n  return getAll(cookieStore)[name];\n};\n\nvar minifyGraphQLQuery = function minifyGraphQLQuery(query) {\n  return query.replace(/(\\n| )*( |{|})(\\n| )*/gm, function (_chars, _spaces, brackets) {\n    return brackets;\n  });\n};\n\nvar preview = \"io.prismic.preview\";\nvar cookie = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  preview: preview\n});\n\nvar ForbiddenError = /*#__PURE__*/function (_PrismicError) {\n  _inherits(ForbiddenError, _PrismicError);\n\n  var _super2 = _createSuper(ForbiddenError);\n\n  function ForbiddenError() {\n    _classCallCheck(this, ForbiddenError);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return _createClass(ForbiddenError);\n}(PrismicError);\n\nvar NotFoundError = /*#__PURE__*/function (_PrismicError2) {\n  _inherits(NotFoundError, _PrismicError2);\n\n  var _super3 = _createSuper(NotFoundError);\n\n  function NotFoundError() {\n    _classCallCheck(this, NotFoundError);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return _createClass(NotFoundError);\n}(PrismicError);\n\nvar ParsingError = /*#__PURE__*/function (_PrismicError3) {\n  _inherits(ParsingError, _PrismicError3);\n\n  var _super4 = _createSuper(ParsingError);\n\n  function ParsingError() {\n    _classCallCheck(this, ParsingError);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return _createClass(ParsingError);\n}(PrismicError);\n\nvar formatValue = function formatValue(value) {\n  if (Array.isArray(value)) {\n    return \"[\".concat(value.map(formatValue).join(\", \"), \"]\");\n  }\n\n  if (typeof value === \"string\") {\n    return \"\\\"\".concat(value, \"\\\"\");\n  }\n\n  if (value instanceof Date) {\n    return \"\".concat(value.getTime());\n  }\n\n  return \"\".concat(value);\n};\n\nvar pathWithArgsPredicate = function pathWithArgsPredicate(name) {\n  var fn = function fn(path) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var formattedArgs = args.map(formatValue).join(\", \");\n    var joiner = path && args.length ? \", \" : \"\";\n    return \"[\".concat(name, \"(\").concat(path).concat(joiner).concat(formattedArgs, \")]\");\n  };\n\n  return fn;\n};\n\nvar pathPredicate = function pathPredicate(name) {\n  var predicateFn = pathWithArgsPredicate(name);\n\n  var fn = function fn(path) {\n    return predicateFn(path);\n  };\n\n  return fn;\n};\n\nvar argsPredicate = function argsPredicate(name) {\n  var predicateFn = pathWithArgsPredicate(name);\n\n  var fn = function fn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return predicateFn.apply(void 0, [\"\"].concat(args));\n  };\n\n  return fn;\n};\n\nvar predicate = {\n  at: pathWithArgsPredicate(\"at\"),\n  not: pathWithArgsPredicate(\"not\"),\n  any: pathWithArgsPredicate(\"any\"),\n  in: pathWithArgsPredicate(\"in\"),\n  fulltext: pathWithArgsPredicate(\"fulltext\"),\n  has: pathPredicate(\"has\"),\n  missing: pathPredicate(\"missing\"),\n  similar: argsPredicate(\"similar\"),\n  geopointNear: pathWithArgsPredicate(\"geopoint.near\"),\n  numberLessThan: pathWithArgsPredicate(\"number.lt\"),\n  numberGreaterThan: pathWithArgsPredicate(\"number.gt\"),\n  numberInRange: pathWithArgsPredicate(\"number.inRange\"),\n  dateAfter: pathWithArgsPredicate(\"date.after\"),\n  dateBefore: pathWithArgsPredicate(\"date.before\"),\n  dateBetween: pathWithArgsPredicate(\"date.between\"),\n  dateDayOfMonth: pathWithArgsPredicate(\"date.day-of-month\"),\n  dateDayOfMonthAfter: pathWithArgsPredicate(\"date.day-of-month-after\"),\n  dateDayOfMonthBefore: pathWithArgsPredicate(\"date.day-of-month-before\"),\n  dateDayOfWeek: pathWithArgsPredicate(\"date.day-of-week\"),\n  dateDayOfWeekAfter: pathWithArgsPredicate(\"date.day-of-week-after\"),\n  dateDayOfWeekBefore: pathWithArgsPredicate(\"date.day-of-week-before\"),\n  dateMonth: pathWithArgsPredicate(\"date.month\"),\n  dateMonthAfter: pathWithArgsPredicate(\"date.month-after\"),\n  dateMonthBefore: pathWithArgsPredicate(\"date.month-before\"),\n  dateYear: pathWithArgsPredicate(\"date.year\"),\n  dateHour: pathWithArgsPredicate(\"date.hour\"),\n  dateHourAfter: pathWithArgsPredicate(\"date.hour-after\"),\n  dateHourBefore: pathWithArgsPredicate(\"date.hour-before\")\n};\nvar MAX_PAGE_SIZE = 100;\nvar REPOSITORY_CACHE_TTL = 5e3;\nvar GET_ALL_QUERY_DELAY = 500;\n\nvar typePredicate = function typePredicate(documentType) {\n  return predicate.at(\"document.type\", documentType);\n};\n\nvar everyTagPredicate = function everyTagPredicate(tags) {\n  return predicate.at(\"document.tags\", castArray(tags));\n};\n\nvar someTagsPredicate = function someTagsPredicate(tags) {\n  return predicate.any(\"document.tags\", castArray(tags));\n};\n\nvar createClient = function createClient() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _construct(Client, args);\n};\n\nvar Client = /*#__PURE__*/function () {\n  function Client(endpoint) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Client);\n\n    this.refState = {\n      mode: \"Master\"\n      /* Master */\n      ,\n      autoPreviewsEnabled: true\n    };\n    this.cachedRepositoryExpiration = 0;\n\n    if (process.env.NODE_ENV === \"development\" && /\\.prismic\\.io\\/(?!api\\/v2\\/?)/.test(endpoint)) {\n      throw new PrismicError(\"@prismicio/client only supports Prismic Rest API V2. Please use the getEndpoint helper to generate a valid Rest API V2 endpoint URL.\", void 0, void 0);\n    }\n\n    this.endpoint = endpoint;\n    this.accessToken = options.accessToken;\n    this.routes = options.routes;\n    this.defaultParams = options.defaultParams;\n\n    if (options.ref) {\n      this.queryContentFromRef(options.ref);\n    }\n\n    if (typeof options.fetch === \"function\") {\n      this.fetchFn = options.fetch;\n    } else if (typeof globalThis.fetch === \"function\") {\n      this.fetchFn = globalThis.fetch;\n    } else {\n      throw new PrismicError(\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\", void 0, void 0);\n    }\n\n    if (this.fetchFn === globalThis.fetch) {\n      this.fetchFn = this.fetchFn.bind(globalThis);\n    }\n\n    this.graphqlFetch = this.graphqlFetch.bind(this);\n  }\n\n  _createClass(Client, [{\n    key: \"enableAutoPreviews\",\n    value: function enableAutoPreviews() {\n      this.refState.autoPreviewsEnabled = true;\n    }\n  }, {\n    key: \"enableAutoPreviewsFromReq\",\n    value: function enableAutoPreviewsFromReq(req) {\n      this.refState.httpRequest = req;\n      this.refState.autoPreviewsEnabled = true;\n    }\n  }, {\n    key: \"disableAutoPreviews\",\n    value: function disableAutoPreviews() {\n      this.refState.autoPreviewsEnabled = false;\n    }\n  }, {\n    key: \"query\",\n    value: function () {\n      var _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(predicates, params) {\n        var url;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.buildQueryURL(_objectSpread(_objectSpread({}, params), {}, {\n                  predicates: predicates\n                }));\n\n              case 2:\n                url = _context.sent;\n                _context.next = 5;\n                return this.fetch(url, params);\n\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function query(_x, _x2) {\n        return _query.apply(this, arguments);\n      }\n\n      return query;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params) {\n        var url;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.buildQueryURL(params);\n\n              case 2:\n                url = _context2.sent;\n                _context2.next = 5;\n                return this.fetch(url, params);\n\n              case 5:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getFirst\",\n    value: function () {\n      var _getFirst = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {\n        var url, result, firstResult;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.buildQueryURL(params);\n\n              case 2:\n                url = _context3.sent;\n                _context3.next = 5;\n                return this.fetch(url, params);\n\n              case 5:\n                result = _context3.sent;\n                firstResult = result.results[0];\n\n                if (!firstResult) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", firstResult);\n\n              case 9:\n                throw new PrismicError(\"No documents were returned\", url, void 0);\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getFirst(_x4) {\n        return _getFirst.apply(this, arguments);\n      }\n\n      return getFirst;\n    }()\n  }, {\n    key: \"dangerouslyGetAll\",\n    value: function () {\n      var _dangerouslyGetAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var params,\n            _params$limit,\n            limit,\n            actualParams,\n            resolvedParams,\n            documents,\n            latestResult,\n            page,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                params = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n                _params$limit = params.limit, limit = _params$limit === void 0 ? Infinity : _params$limit, actualParams = _objectWithoutProperties(params, _excluded2);\n                resolvedParams = _objectSpread(_objectSpread({}, actualParams), {}, {\n                  pageSize: actualParams.pageSize || MAX_PAGE_SIZE\n                });\n                documents = [];\n\n              case 4:\n                if (!((!latestResult || latestResult.next_page) && documents.length < limit)) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                page = latestResult ? latestResult.page + 1 : void 0;\n                _context4.next = 8;\n                return this.get(_objectSpread(_objectSpread({}, resolvedParams), {}, {\n                  page: page\n                }));\n\n              case 8:\n                latestResult = _context4.sent;\n                documents.push.apply(documents, _toConsumableArray(latestResult.results));\n\n                if (!latestResult.next_page) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                _context4.next = 13;\n                return new Promise(function (res) {\n                  return setTimeout(res, GET_ALL_QUERY_DELAY);\n                });\n\n              case 13:\n                _context4.next = 4;\n                break;\n\n              case 15:\n                return _context4.abrupt(\"return\", documents.slice(0, limit));\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function dangerouslyGetAll() {\n        return _dangerouslyGetAll.apply(this, arguments);\n      }\n\n      return dangerouslyGetAll;\n    }()\n  }, {\n    key: \"getByID\",\n    value: function () {\n      var _getByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id, params) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getFirst(appendPredicates(params, predicate.at(\"document.id\", id)));\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getByID(_x5, _x6) {\n        return _getByID.apply(this, arguments);\n      }\n\n      return getByID;\n    }()\n  }, {\n    key: \"getByIDs\",\n    value: function () {\n      var _getByIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(ids, params) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.get(appendPredicates(params, predicate.in(\"document.id\", ids)));\n\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getByIDs(_x7, _x8) {\n        return _getByIDs.apply(this, arguments);\n      }\n\n      return getByIDs;\n    }()\n  }, {\n    key: \"getAllByIDs\",\n    value: function () {\n      var _getAllByIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(ids, params) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, predicate.in(\"document.id\", ids)));\n\n              case 2:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAllByIDs(_x9, _x10) {\n        return _getAllByIDs.apply(this, arguments);\n      }\n\n      return getAllByIDs;\n    }()\n  }, {\n    key: \"getByUID\",\n    value: function () {\n      var _getByUID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(documentType, uid, params) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getFirst(appendPredicates(params, [typePredicate(documentType), predicate.at(\"my.\".concat(documentType, \".uid\"), uid)]));\n\n              case 2:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getByUID(_x11, _x12, _x13) {\n        return _getByUID.apply(this, arguments);\n      }\n\n      return getByUID;\n    }()\n  }, {\n    key: \"getByUIDs\",\n    value: function () {\n      var _getByUIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(documentType, uids, params) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.get(appendPredicates(params, [typePredicate(documentType), predicate.in(\"my.\".concat(documentType, \".uid\"), uids)]));\n\n              case 2:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getByUIDs(_x14, _x15, _x16) {\n        return _getByUIDs.apply(this, arguments);\n      }\n\n      return getByUIDs;\n    }()\n  }, {\n    key: \"getAllByUIDs\",\n    value: function () {\n      var _getAllByUIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(documentType, uids, params) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, [typePredicate(documentType), predicate.in(\"my.\".concat(documentType, \".uid\"), uids)]));\n\n              case 2:\n                return _context10.abrupt(\"return\", _context10.sent);\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getAllByUIDs(_x17, _x18, _x19) {\n        return _getAllByUIDs.apply(this, arguments);\n      }\n\n      return getAllByUIDs;\n    }()\n  }, {\n    key: \"getSingle\",\n    value: function () {\n      var _getSingle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(documentType, params) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.getFirst(appendPredicates(params, typePredicate(documentType)));\n\n              case 2:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSingle(_x20, _x21) {\n        return _getSingle.apply(this, arguments);\n      }\n\n      return getSingle;\n    }()\n  }, {\n    key: \"getByType\",\n    value: function () {\n      var _getByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(documentType, params) {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.get(appendPredicates(params, typePredicate(documentType)));\n\n              case 2:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getByType(_x22, _x23) {\n        return _getByType.apply(this, arguments);\n      }\n\n      return getByType;\n    }()\n  }, {\n    key: \"getAllByType\",\n    value: function () {\n      var _getAllByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(documentType, params) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, typePredicate(documentType)));\n\n              case 2:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getAllByType(_x24, _x25) {\n        return _getAllByType.apply(this, arguments);\n      }\n\n      return getAllByType;\n    }()\n  }, {\n    key: \"getByTag\",\n    value: function () {\n      var _getByTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(tag, params) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.get(appendPredicates(params, someTagsPredicate(tag)));\n\n              case 2:\n                return _context14.abrupt(\"return\", _context14.sent);\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getByTag(_x26, _x27) {\n        return _getByTag.apply(this, arguments);\n      }\n\n      return getByTag;\n    }()\n  }, {\n    key: \"getAllByTag\",\n    value: function () {\n      var _getAllByTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(tag, params) {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, someTagsPredicate(tag)));\n\n              case 2:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 3:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getAllByTag(_x28, _x29) {\n        return _getAllByTag.apply(this, arguments);\n      }\n\n      return getAllByTag;\n    }()\n  }, {\n    key: \"getByEveryTag\",\n    value: function () {\n      var _getByEveryTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(tags, params) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.get(appendPredicates(params, everyTagPredicate(tags)));\n\n              case 2:\n                return _context16.abrupt(\"return\", _context16.sent);\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function getByEveryTag(_x30, _x31) {\n        return _getByEveryTag.apply(this, arguments);\n      }\n\n      return getByEveryTag;\n    }()\n  }, {\n    key: \"getAllByEveryTag\",\n    value: function () {\n      var _getAllByEveryTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(tags, params) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, everyTagPredicate(tags)));\n\n              case 2:\n                return _context17.abrupt(\"return\", _context17.sent);\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getAllByEveryTag(_x32, _x33) {\n        return _getAllByEveryTag.apply(this, arguments);\n      }\n\n      return getAllByEveryTag;\n    }()\n  }, {\n    key: \"getBySomeTags\",\n    value: function () {\n      var _getBySomeTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(tags, params) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.get(appendPredicates(params, someTagsPredicate(tags)));\n\n              case 2:\n                return _context18.abrupt(\"return\", _context18.sent);\n\n              case 3:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function getBySomeTags(_x34, _x35) {\n        return _getBySomeTags.apply(this, arguments);\n      }\n\n      return getBySomeTags;\n    }()\n  }, {\n    key: \"getAllBySomeTags\",\n    value: function () {\n      var _getAllBySomeTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(tags, params) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.dangerouslyGetAll(appendPredicates(params, someTagsPredicate(tags)));\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getAllBySomeTags(_x36, _x37) {\n        return _getAllBySomeTags.apply(this, arguments);\n      }\n\n      return getAllBySomeTags;\n    }()\n  }, {\n    key: \"getRepository\",\n    value: function () {\n      var _getRepository = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(params) {\n        var url;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                url = new URL(this.endpoint);\n\n                if (this.accessToken) {\n                  url.searchParams.set(\"access_token\", this.accessToken);\n                }\n\n                _context20.next = 4;\n                return this.fetch(url.toString(), params);\n\n              case 4:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 5:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function getRepository(_x38) {\n        return _getRepository.apply(this, arguments);\n      }\n\n      return getRepository;\n    }()\n  }, {\n    key: \"getRefs\",\n    value: function () {\n      var _getRefs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(params) {\n        var repository;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.getRepository(params);\n\n              case 2:\n                repository = _context21.sent;\n                return _context21.abrupt(\"return\", repository.refs);\n\n              case 4:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getRefs(_x39) {\n        return _getRefs.apply(this, arguments);\n      }\n\n      return getRefs;\n    }()\n  }, {\n    key: \"getRefByID\",\n    value: function () {\n      var _getRefByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(id, params) {\n        var refs;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this.getRefs(params);\n\n              case 2:\n                refs = _context22.sent;\n                return _context22.abrupt(\"return\", findRefByID(refs, id));\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function getRefByID(_x40, _x41) {\n        return _getRefByID.apply(this, arguments);\n      }\n\n      return getRefByID;\n    }()\n  }, {\n    key: \"getRefByLabel\",\n    value: function () {\n      var _getRefByLabel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(label, params) {\n        var refs;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.getRefs(params);\n\n              case 2:\n                refs = _context23.sent;\n                return _context23.abrupt(\"return\", findRefByLabel(refs, label));\n\n              case 4:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function getRefByLabel(_x42, _x43) {\n        return _getRefByLabel.apply(this, arguments);\n      }\n\n      return getRefByLabel;\n    }()\n  }, {\n    key: \"getMasterRef\",\n    value: function () {\n      var _getMasterRef = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(params) {\n        var refs;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.getRefs(params);\n\n              case 2:\n                refs = _context24.sent;\n                return _context24.abrupt(\"return\", findMasterRef(refs));\n\n              case 4:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function getMasterRef(_x44) {\n        return _getMasterRef.apply(this, arguments);\n      }\n\n      return getMasterRef;\n    }()\n  }, {\n    key: \"getReleases\",\n    value: function () {\n      var _getReleases = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(params) {\n        var refs;\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.getRefs(params);\n\n              case 2:\n                refs = _context25.sent;\n                return _context25.abrupt(\"return\", refs.filter(function (ref) {\n                  return !ref.isMasterRef;\n                }));\n\n              case 4:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function getReleases(_x45) {\n        return _getReleases.apply(this, arguments);\n      }\n\n      return getReleases;\n    }()\n  }, {\n    key: \"getReleaseByID\",\n    value: function () {\n      var _getReleaseByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(id, params) {\n        var releases;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this.getReleases(params);\n\n              case 2:\n                releases = _context26.sent;\n                return _context26.abrupt(\"return\", findRefByID(releases, id));\n\n              case 4:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function getReleaseByID(_x46, _x47) {\n        return _getReleaseByID.apply(this, arguments);\n      }\n\n      return getReleaseByID;\n    }()\n  }, {\n    key: \"getReleaseByLabel\",\n    value: function () {\n      var _getReleaseByLabel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(label, params) {\n        var releases;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this.getReleases(params);\n\n              case 2:\n                releases = _context27.sent;\n                return _context27.abrupt(\"return\", findRefByLabel(releases, label));\n\n              case 4:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function getReleaseByLabel(_x48, _x49) {\n        return _getReleaseByLabel.apply(this, arguments);\n      }\n\n      return getReleaseByLabel;\n    }()\n  }, {\n    key: \"getTags\",\n    value: function () {\n      var _getTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(params) {\n        var tagsForm, repository;\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.prev = 0;\n                _context28.next = 3;\n                return this.getCachedRepositoryForm(\"tags\", params);\n\n              case 3:\n                tagsForm = _context28.sent;\n                _context28.next = 6;\n                return this.fetch(tagsForm.action);\n\n              case 6:\n                return _context28.abrupt(\"return\", _context28.sent);\n\n              case 9:\n                _context28.prev = 9;\n                _context28.t0 = _context28[\"catch\"](0);\n                _context28.next = 13;\n                return this.getRepository(params);\n\n              case 13:\n                repository = _context28.sent;\n                return _context28.abrupt(\"return\", repository.tags);\n\n              case 15:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this, [[0, 9]]);\n      }));\n\n      function getTags(_x50) {\n        return _getTags.apply(this, arguments);\n      }\n\n      return getTags;\n    }()\n  }, {\n    key: \"buildQueryURL\",\n    value: function () {\n      var _buildQueryURL2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n        var _ref,\n            signal,\n            params,\n            ref,\n            integrationFieldsRef,\n            _args29 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _ref = _args29.length > 0 && _args29[0] !== undefined ? _args29[0] : {}, signal = _ref.signal, params = _objectWithoutProperties(_ref, _excluded3);\n                _context29.t0 = params.ref;\n\n                if (_context29.t0) {\n                  _context29.next = 6;\n                  break;\n                }\n\n                _context29.next = 5;\n                return this.getResolvedRefString();\n\n              case 5:\n                _context29.t0 = _context29.sent;\n\n              case 6:\n                ref = _context29.t0;\n                _context29.t2 = params.integrationFieldsRef;\n\n                if (_context29.t2) {\n                  _context29.next = 12;\n                  break;\n                }\n\n                _context29.next = 11;\n                return this.getCachedRepository({\n                  signal: signal\n                });\n\n              case 11:\n                _context29.t2 = _context29.sent.integrationFieldsRef;\n\n              case 12:\n                _context29.t1 = _context29.t2;\n\n                if (_context29.t1) {\n                  _context29.next = 15;\n                  break;\n                }\n\n                _context29.t1 = void 0;\n\n              case 15:\n                integrationFieldsRef = _context29.t1;\n                return _context29.abrupt(\"return\", _buildQueryURL(this.endpoint, _objectSpread(_objectSpread(_objectSpread({}, this.defaultParams), params), {}, {\n                  ref: ref,\n                  integrationFieldsRef: integrationFieldsRef,\n                  routes: params.routes || this.routes,\n                  accessToken: params.accessToken || this.accessToken\n                })));\n\n              case 17:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n\n      function buildQueryURL() {\n        return _buildQueryURL2.apply(this, arguments);\n      }\n\n      return buildQueryURL;\n    }()\n  }, {\n    key: \"resolvePreviewURL\",\n    value: function () {\n      var _resolvePreviewURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(args) {\n        var _a, documentID, previewToken, searchParams, document;\n\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                documentID = args.documentID;\n                previewToken = args.previewToken;\n\n                if (typeof globalThis.location !== \"undefined\") {\n                  searchParams = new URLSearchParams(globalThis.location.search);\n                  documentID = documentID || searchParams.get(\"documentId\") || void 0;\n                  previewToken = previewToken || searchParams.get(\"token\") || void 0;\n                } else if ((_a = this.refState.httpRequest) == null ? void 0 : _a.query) {\n                  documentID = documentID || this.refState.httpRequest.query.documentId;\n                  previewToken = previewToken || this.refState.httpRequest.query.token;\n                }\n\n                if (!(documentID != null)) {\n                  _context30.next = 10;\n                  break;\n                }\n\n                _context30.next = 6;\n                return this.getByID(documentID, {\n                  signal: args.signal,\n                  ref: previewToken,\n                  lang: \"*\"\n                });\n\n              case 6:\n                document = _context30.sent;\n                return _context30.abrupt(\"return\", prismicH.asLink(document, args.linkResolver));\n\n              case 10:\n                return _context30.abrupt(\"return\", args.defaultURL);\n\n              case 11:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n\n      function resolvePreviewURL(_x51) {\n        return _resolvePreviewURL.apply(this, arguments);\n      }\n\n      return resolvePreviewURL;\n    }()\n  }, {\n    key: \"queryLatestContent\",\n    value: function queryLatestContent() {\n      this.refState.mode = \"Master\"\n      /* Master */\n      ;\n    }\n  }, {\n    key: \"queryContentFromReleaseByID\",\n    value: function queryContentFromReleaseByID(releaseID) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: \"ReleaseID\"\n        /* ReleaseID */\n        ,\n        releaseID: releaseID\n      });\n    }\n  }, {\n    key: \"queryContentFromReleaseByLabel\",\n    value: function queryContentFromReleaseByLabel(releaseLabel) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: \"ReleaseLabel\"\n        /* ReleaseLabel */\n        ,\n        releaseLabel: releaseLabel\n      });\n    }\n  }, {\n    key: \"queryContentFromRef\",\n    value: function queryContentFromRef(ref) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: \"Manual\"\n        /* Manual */\n        ,\n        ref: ref\n      });\n    }\n  }, {\n    key: \"graphqlFetch\",\n    value: function () {\n      var _graphqlFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(input, init) {\n        var cachedRepository, ref, unsanitizedHeaders, headers, key, url, query;\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this.getCachedRepository();\n\n              case 2:\n                cachedRepository = _context31.sent;\n                _context31.next = 5;\n                return this.getResolvedRefString();\n\n              case 5:\n                ref = _context31.sent;\n                unsanitizedHeaders = _objectSpread({\n                  \"Prismic-ref\": ref,\n                  \"Prismic-integration-field-ref\": cachedRepository.integrationFieldsRef || \"\",\n                  Authorization: this.accessToken ? \"Token \".concat(this.accessToken) : \"\"\n                }, init ? init.headers : {});\n                headers = {};\n\n                for (key in unsanitizedHeaders) {\n                  if (unsanitizedHeaders[key]) {\n                    headers[key.toLowerCase()] = unsanitizedHeaders[key];\n                  }\n                }\n\n                url = new URL(input);\n                query = url.searchParams.get(\"query\");\n\n                if (query) {\n                  url.searchParams.set(\"query\", minifyGraphQLQuery(query));\n                }\n\n                _context31.next = 14;\n                return this.fetchFn(url.toString(), _objectSpread(_objectSpread({}, init), {}, {\n                  headers: headers\n                }));\n\n              case 14:\n                return _context31.abrupt(\"return\", _context31.sent);\n\n              case 15:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n\n      function graphqlFetch(_x52, _x53) {\n        return _graphqlFetch.apply(this, arguments);\n      }\n\n      return graphqlFetch;\n    }()\n  }, {\n    key: \"getCachedRepository\",\n    value: function () {\n      var _getCachedRepository = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(params) {\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                if (!(!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration)) {\n                  _context32.next = 5;\n                  break;\n                }\n\n                this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n                _context32.next = 4;\n                return this.getRepository(params);\n\n              case 4:\n                this.cachedRepository = _context32.sent;\n\n              case 5:\n                return _context32.abrupt(\"return\", this.cachedRepository);\n\n              case 6:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n\n      function getCachedRepository(_x54) {\n        return _getCachedRepository.apply(this, arguments);\n      }\n\n      return getCachedRepository;\n    }()\n  }, {\n    key: \"getCachedRepositoryForm\",\n    value: function () {\n      var _getCachedRepositoryForm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(name, params) {\n        var cachedRepository, form;\n        return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                _context33.next = 2;\n                return this.getCachedRepository(params);\n\n              case 2:\n                cachedRepository = _context33.sent;\n                form = cachedRepository.forms[name];\n\n                if (form) {\n                  _context33.next = 6;\n                  break;\n                }\n\n                throw new PrismicError(\"Form with name \\\"\".concat(name, \"\\\" could not be found\"), void 0, void 0);\n\n              case 6:\n                return _context33.abrupt(\"return\", form);\n\n              case 7:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this);\n      }));\n\n      function getCachedRepositoryForm(_x55, _x56) {\n        return _getCachedRepositoryForm.apply(this, arguments);\n      }\n\n      return getCachedRepositoryForm;\n    }()\n  }, {\n    key: \"getResolvedRefString\",\n    value: function () {\n      var _getResolvedRefString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(params) {\n        var _a, _b, _c, previewRef, cachedRepository, refModeType, res;\n\n        return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                if (!this.refState.autoPreviewsEnabled) {\n                  _context34.next = 5;\n                  break;\n                }\n\n                previewRef = void 0;\n\n                if ((_a = globalThis.document) == null ? void 0 : _a.cookie) {\n                  previewRef = getCookie(preview, globalThis.document.cookie);\n                } else if ((_c = (_b = this.refState.httpRequest) == null ? void 0 : _b.headers) == null ? void 0 : _c.cookie) {\n                  previewRef = getCookie(preview, this.refState.httpRequest.headers.cookie);\n                }\n\n                if (!previewRef) {\n                  _context34.next = 5;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\", previewRef);\n\n              case 5:\n                _context34.next = 7;\n                return this.getCachedRepository(params);\n\n              case 7:\n                cachedRepository = _context34.sent;\n                refModeType = this.refState.mode;\n\n                if (!(refModeType === \"ReleaseID\"\n                /* ReleaseID */\n                )) {\n                  _context34.next = 13;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\", findRefByID(cachedRepository.refs, this.refState.releaseID).ref);\n\n              case 13:\n                if (!(refModeType === \"ReleaseLabel\"\n                /* ReleaseLabel */\n                )) {\n                  _context34.next = 17;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\", findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref);\n\n              case 17:\n                if (!(refModeType === \"Manual\"\n                /* Manual */\n                )) {\n                  _context34.next = 23;\n                  break;\n                }\n\n                _context34.next = 20;\n                return castThunk(this.refState.ref)();\n\n              case 20:\n                res = _context34.sent;\n\n                if (!(typeof res === \"string\")) {\n                  _context34.next = 23;\n                  break;\n                }\n\n                return _context34.abrupt(\"return\", res);\n\n              case 23:\n                return _context34.abrupt(\"return\", findMasterRef(cachedRepository.refs).ref);\n\n              case 24:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n\n      function getResolvedRefString(_x57) {\n        return _getResolvedRefString.apply(this, arguments);\n      }\n\n      return getResolvedRefString;\n    }()\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(url) {\n        var params,\n            res,\n            json,\n            _args35 = arguments;\n        return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                params = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : {};\n                _context35.next = 3;\n                return this.fetchFn(url, {\n                  signal: params.signal\n                });\n\n              case 3:\n                res = _context35.sent;\n                _context35.prev = 4;\n                _context35.next = 7;\n                return res.json();\n\n              case 7:\n                json = _context35.sent;\n                _context35.next = 17;\n                break;\n\n              case 10:\n                _context35.prev = 10;\n                _context35.t0 = _context35[\"catch\"](4);\n\n                if (!(res.status === 404)) {\n                  _context35.next = 16;\n                  break;\n                }\n\n                throw new NotFoundError(\"Prismic repository not found. Check that \\\"\".concat(this.endpoint, \"\\\" is pointing to the correct repository.\"), url, void 0);\n\n              case 16:\n                throw new PrismicError(void 0, url, void 0);\n\n              case 17:\n                _context35.t1 = res.status;\n                _context35.next = _context35.t1 === 200 ? 20 : _context35.t1 === 400 ? 21 : _context35.t1 === 401 ? 22 : _context35.t1 === 403 ? 22 : 23;\n                break;\n\n              case 20:\n                return _context35.abrupt(\"return\", json);\n\n              case 21:\n                throw new ParsingError(json.message, url, json);\n\n              case 22:\n                throw new ForbiddenError(\"error\" in json ? json.error : json.message, url, json);\n\n              case 23:\n                throw new PrismicError(void 0, url, json);\n\n              case 24:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this, [[4, 10]]);\n      }));\n\n      function fetch(_x58) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }]);\n\n  return Client;\n}();\n\nvar predicates = predicate;\nvar Predicates = predicate;\nexport { Client, ForbiddenError, NotFoundError, ParsingError, Predicates, PrismicError, _buildQueryURL as buildQueryURL, cookie, createClient, getEndpoint, getGraphQLEndpoint, predicate, predicates };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;IAQaA,cAAc,SAAdA,WAAc,CAC1BC,cAD0B;AAAA,2BAGfA,cAHe;AAAA;;ICAdC,qBAAqB,SAArBA,kBAAqB,CACjCD,cADiC;AAAA,2BAGtBA,cAHsB;AAAA;;ICErBE,YAAY,SAAZA,SAAY,CAAIC,CAAJ;AAAA,SAAyBC,MAAMC,OAAN,CAAcF,CAAd,IAAmBA,CAAnB,GAAuB,CAACA,CAAD,CAAhD;AAAA;;AC8GzB,IAAMG,iBAAiB;AACtBC,eAAa;AADS,CAAvB;;AAsBA,IAAMC,uBAAuB,SAAvBA,oBAAuB,CAACC,QAAD;AAAA,SAC5B,OAAOA,QAAP,KAAoB,QAApB,GACGA,QADH,GAEG,CACAA,SAASC,KADT,EAEAD,SAASE,SAAT,KAAuB,MAAvB,GAAgCF,SAASE,SAAzC,GAAqD,MAFrD,EAICC,MAJD,CAIQC,OAJR,EAKCC,IALD,CAKM,GALN,CAHyB;AAAA,CAA7B;;IA6BaC,iBAAgB,SAAhBA,aAAgB,CAC5BC,QAD4B,EAE5BC,IAF4B,EAGhB;AA9Kb;;AA+KC,MAAQC,UAAR,GAAkCD,IAAlC,CAAQC,UAAR;AAAA,MAAuBC,MAAvB,4BAAkCF,IAAlC;;AAEA,MAAMG,MAAM,IAAIC,GAAJ,+BAA+BL,QAA/B,OAAZ;;AAEA,MAAIE,UAAJ,EAAgB;AAAA,+CACShB,UAAUgB,UAAV,CADT;AAAA;;AAAA;AACf,0DAA+C;AAAA,YAApCI,UAAoC;AAC9CF,YAAIG,YAAJ,CAAiBC,MAAjB,CAAwB,GAAxB,aAAiCF,UAAjC;AAAiC;AAFnB;AAAA;AAAA;AAAA;AAAA;AAEmB;;AAMnC,WAAWG,CAAX,IAAgBN,MAAhB,EAAwB;AACvB,QAAMO,OAAQ,qBAAeD,CAAf,kBACbA,CADD;AAGA,QAAIE,QAAQR,OAAOM,CAAP,CAAZ;;AAEA,QAAIC,SAAS,WAAb,EAA0B;AACzB,UAAME,cAAcT,OAAOO,IAAP,CAApB;;AAEA,UAAIE,eAAe,IAAnB,EAAyB;AACxB,YAAMC,IAAI3B,UAAU0B,WAAV,EACRE,GADQ,CACJ,UAACrB,QAAD;AAAA,iBAAcD,qBAAqBC,QAArB,CAAd;AAAA,SADI,EAERK,IAFQ,CAEH,GAFG,CAAV;AAIAa,2BAAYE,CAAZ;AAAY;AAAA,KARd,MAQc,IAEHH,SAAS,QAFN,EAEgB;AAC7B,UAAI,OAAOP,OAAOO,IAAP,CAAP,KAAwB,QAA5B,EAAsC;AACrCC,gBAAQI,KAAKC,SAAL,CAAe9B,UAAUiB,OAAOO,IAAP,CAAV,CAAf,CAAR;AAAwC;AAAA;;AAI1C,QAAIC,SAAS,IAAb,EAAmB;AAClBP,UAAIG,YAAJ,CAAiBU,GAAjB,CAAqBP,IAArB,EAA2BxB,UAAUyB,KAAV,EAAiBb,IAAjB,CAAsB,GAAtB,CAA3B;AAAiD;AAAA;;AAInD,SAAOM,IAAIc,QAAJ,EAAP;AAAW;;ICtMCC,mBAAmB,SAAnBA,gBAAmB,GAG3B;AAAA,MAFJC,iBAEI,uEAFmB,EAEnB;AAAA,MADJlB,UACI;AACJ,yCACIkB,iBADJ;AAEClB,6CACKkB,kBAAkBlB,UAAlB,IAAgC,EADrC,sBAEIhB,UAAUgB,UAAV,CAFJ;AAFD;AAIe;;ICfHmB,YAAY,SAAZA,SAAY,CAAIlC,CAAJ;AAAA,SACxB,OAAOA,CAAP,KAAa,UAAb,GAA2BA,CAA3B,GAA2C;AAAA,WAAMA,CAAN;AAAA,GADnB;AAAA;;;;;;;ACLxB,0BAIE;AAAA;;AAAA,QAHDmC,OAGC,uEAHS,sCAGT;AAAA,QAFDlB,GAEC;AAAA,QADDmB,QACC;;AAAA;;AACD,8BAAMD,OAAN;AAEA,UAAKlB,GAAL,GAAWA,GAAX;AACA,UAAKmB,QAAL,GAAgBA,QAAhB;AAJC;AAIe;;;iCAZ0BC,K;;ICe/BC,UAAU,SAAVA,OAAU,CACtBC,IADsB,EAEtBpB,SAFsB,EAGJ;AAClB,MAAMqB,MAAMD,KAAKE,IAAL,CAAU,UAACC,IAAD;AAAA,WAASvB,UAAUuB,IAAV,CAAT;AAAA,GAAV,CAAZ;;AAEA,MAAI,CAACF,GAAL,EAAU;AACT,UAAM,IAAIG,YAAJ,CAAiB,yBAAjB,EAA4C,MAA5C,EAAuD,MAAvD,CAAN;AAA6D;;AAG9D,SAAOH,GAAP;AAAO;;ICbKI,gBAAgB,SAAhBA,aAAgB,CAACL,IAAD,EAAwC;AACpE,SAAOD,QAAQC,IAAR,EAAc,UAACC,GAAD;AAAA,WAASA,IAAIK,WAAb;AAAA,GAAd,CAAP;AAAkC;;ICAtBC,cAAc,SAAdA,WAAc,CAACP,IAAD,EAAuBQ,EAAvB,EAAoD;AAC9E,SAAOT,QAAQC,IAAR,EAAc,UAACC,GAAD;AAAA,WAASA,IAAIO,EAAJ,KAAWA,EAApB;AAAA,GAAd,CAAP;AAAyC;;ICD7BC,iBAAiB,SAAjBA,cAAiB,CAC7BT,IAD6B,EAE7BU,KAF6B,EAGX;AAClB,SAAOX,QAAQC,IAAR,EAAc,UAACC,GAAD;AAAA,WAASA,IAAIS,KAAJ,KAAcA,KAAvB;AAAA,GAAd,CAAP;AAA4C;;ACQ7C,IAAMC,YAAY,SAAZA,SAAY,CAAC1B,KAAD,EAA2B;AAC5C,SAAOA,MAAM2B,OAAN,CAAc,MAAd,EAAsB,GAAtB,CAAP;AAA6B,CAD9B;;IAIaC,QAAQ,SAARA,KAAQ,CAACC,YAAD,EAAsD;AAC1E,MAAMC,SAAqC,EAA3C;AACA,MAAMC,UAAUF,aAAaG,KAAb,CAAmB,IAAnB,CAAhB;;AAF0E,8CAIrDD,OAJqD;AAAA;;AAAA;AAI1E,2DAA8B;AAAA,UAAnBE,OAAmB;;AAC7B,UAAMC,QAAQD,QAAOD,KAAP,CAAa,GAAb,CAAd;;AACA,UAAMhC,QAAQkC,MAAMC,KAAN,CAAY,CAAZ,EAAehD,IAAf,CAAoB,GAApB,CAAd;AACA,UAAMY,OAAO2B,UAAUQ,MAAM,CAAN,CAAV,EAAoBP,OAApB,CAA4B,MAA5B,EAAoC,GAApC,CAAb;AACAG,aAAO/B,IAAP,IAAe2B,UAAU1B,KAAV,CAAf;AAAyB;AARgD;AAAA;AAAA;AAAA;AAAA;;AAW1E,SAAO8B,MAAP;AAAO;;AAGR,IAAMM,SAAS,SAATA,MAAS,CAACC,WAAD;AAAA,SACdT,MAAMS,WAAN,CADc;AAAA,CAAf;;IAWaC,YAAY,SAAZA,SAAY,CACxBvC,IADwB,EAExBsC,WAFwB;AAAA,SAGAD,OAAOC,WAAP,EAAoBtC,IAApB,CAHA;AAAA;;IC/CZwC,qBAAqB,SAArBA,kBAAqB,CAACC,KAAD,EAA2B;AAC5D,SAAOA,MAAMb,OAAN,CACN,yBADM,EAEN,UAACc,MAAD,EAASC,OAAT,EAAkBC,QAAlB;AAAA,WAA+BA,QAA/B;AAAA,GAFM,CAAP;AAEgC;;ICPpBC,UAAU;;;;;;;;;;;;;;;;;;ECQazB,Y;;;;;;;;;;;;;;ECTDA,Y;;;;;;;;;;;;;;ECSDA,Y;;ACHlC,IAAM0B,cAAc,SAAdA,WAAc,CACnB7C,KADmB,EAOP;AACZ,MAAIvB,MAAMC,OAAN,CAAcsB,KAAd,CAAJ,EAA0B;AACzB,sBAAWA,MAAMG,GAAN,CAAU0C,WAAV,EAAuB1D,IAAvB,CAA4B,IAA5B,CAAX;AAAuC;;AAGxC,MAAI,OAAOa,KAAP,KAAiB,QAArB,EAA+B;AAC9B,uBAAWA,KAAX;AAAW;;AAGZ,MAAIA,iBAAiB8C,IAArB,EAA2B;AAC1B,qBAAU9C,MAAM+C,OAAN,EAAV;AAAgB;;AAGjB,mBAAU/C,KAAV;AAAU,CApBX;;AA+BA,IAAMgD,wBAAwB,SAAxBA,qBAAwB,CAAyBjD,IAAzB,EAA0C;AAIvE,MAAMkD,KAAK,SAALA,EAAK,CAACC,IAAD,EAAyC;AAAA,sCAAvB5D,IAAuB;AAAvBA,UAAuB;AAAA;;AACnD,QAAM6D,gBAAgB7D,KAAKa,GAAL,CAAS0C,WAAT,EAAsB1D,IAAtB,CAA2B,IAA3B,CAAtB;AACA,QAAMiE,SAASF,QAAQ5D,KAAK+D,MAAb,GAAsB,IAAtB,GAA6B,EAA5C;AAEA,sBAAWtD,IAAX,cAAmBmD,IAAnB,SAA0BE,MAA1B,SAAmCD,aAAnC;AAAmC,GAJpC;;AAOA,SAAOF,EAAP;AAAO,CAXR;;AAqBA,IAAMK,gBAAgB,SAAhBA,aAAgB,CAACvD,IAAD,EAAkB;AACvC,MAAMwD,cAAcP,sBAAsBjD,IAAtB,CAApB;;AAKA,MAAMkD,KAAK,SAALA,EAAK,CAACC,IAAD,EAA0B;AACpC,WAAOK,YAAYL,IAAZ,CAAP;AAAmB,GADpB;;AAIA,SAAOD,EAAP;AAAO,CAVR;;AAoBA,IAAMO,gBAAgB,SAAhBA,aAAgB,CAAyBzD,IAAzB,EAA0C;AAC/D,MAAMwD,cAAcP,sBAA4BjD,IAA5B,CAApB;;AAKA,MAAMkD,KAAK,SAALA,EAAK,GAA2B;AAAA,uCAAvB3D,IAAuB;AAAvBA,UAAuB;AAAA;;AACrC,WAAOiE,2BAAY,EAAZ,SAAmBjE,IAAnB,EAAP;AAA0B,GAD3B;;AAIA,SAAO2D,EAAP;AAAO,CAVR;;IAkBatD,YAAY;AAOxB8D,MAAIT,sBAA4C,IAA5C,CAPoB;AAexBU,OAAKV,sBAA4C,KAA5C,CAfmB;AAwBxBW,OAAKX,sBAA4C,KAA5C,CAxBmB;AAiCxBY,MAAIZ,sBAA4C,IAA5C,CAjCoB;AA6CxBa,YAAUb,sBAA4C,UAA5C,CA7Cc;AAsDxBc,OAAKR,cAAc,KAAd,CAtDmB;AA+DxBS,WAAST,cAAc,SAAd,CA/De;AAwExBU,WAASR,cAA2C,SAA3C,CAxEe;AAkFxBS,gBACCjB,sBAEE,eAFF,CAnFuB;AA6FxBkB,kBAAgBlB,sBAAuC,WAAvC,CA7FQ;AAqGxBmB,qBAAmBnB,sBAAuC,WAAvC,CArGK;AA6GxBoB,iBACCpB,sBACC,gBADD,CA9GuB;AAwHxBqB,aACCrB,sBAAsD,YAAtD,CAzHuB;AAiIxBsB,cACCtB,sBAAsD,aAAtD,CAlIuB;AA0IxBuB,eACCvB,sBAEE,cAFF,CA3IuB;AAqJxBwB,kBAAgBxB,sBAAqC,mBAArC,CArJQ;AA6JxByB,uBAAqBzB,sBACpB,yBADoB,CA7JG;AAuKxB0B,wBAAsB1B,sBACrB,0BADqB,CAvKE;AAiLxB2B,iBACC3B,sBAA8C,kBAA9C,CAlLuB;AA0LxB4B,sBAAoB5B,sBACnB,wBADmB,CA1LI;AAoMxB6B,uBAAqB7B,sBACpB,yBADoB,CApMG;AA8MxB8B,aAAW9B,sBAAgD,YAAhD,CA9Ma;AAsNxB+B,kBACC/B,sBAAgD,kBAAhD,CAvNuB;AA+NxBgC,mBACChC,sBAAgD,mBAAhD,CAhOuB;AAwOxBiC,YAAUjC,sBAAsC,WAAtC,CAxOc;AAgPxBkC,YAAUlC,sBAAsC,WAAtC,CAhPc;AAwPxBmC,iBAAenC,sBAAsC,iBAAtC,CAxPS;AAgQxBoC,kBAAgBpC,sBAAsC,kBAAtC;AAhQQ;ACzEzB,IAAMqC,gBAAgB,GAAtB;IAQaC,uBAAuB;IASvBC,sBAAsB;;AAyKnC,IAAMC,gBAAgB,SAAhBA,aAAgB,CAACC,YAAD;AAAA,SACrB9F,UAAU8D,EAAV,CAAa,eAAb,EAA8BgC,YAA9B,CADqB;AAAA,CAAtB;;AAWA,IAAMC,oBAAoB,SAApBA,iBAAoB,CAACC,IAAD;AAAA,SACzBhG,UAAU8D,EAAV,CAAa,eAAb,EAA8BlF,UAAUoH,IAAV,CAA9B,CADyB;AAAA,CAA1B;;AAWA,IAAMC,oBAAoB,SAApBA,iBAAoB,CAACD,IAAD;AAAA,SACzBhG,UAAUgE,GAAV,CAAc,eAAd,EAA+BpF,UAAUoH,IAAV,CAA/B,CADyB;AAAA,CAA1B;;IAaaE,eAAe,SAAfA,YAAe;AAAA,qCACxBvG,IADwB;AACxBA,QADwB;AAAA;;AAAA,oBAEXwG,MAFW,EAEDxG,IAFC;AAAA;;;AAkF3B,kBAAYD,QAAZ,EAA0D;AAAA,QAA5B0G,OAA4B,uEAAJ,EAAI;;AAAA;;AA7BlD,oBAAqB;AAC5BC,YAAM;AAAA;AADsB;AAE5BC,2BAAqB;AAFO,KAArB;AAaA,sCAA6B,CAA7B;;AAiBP,QACCC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,aAAzB,IACA,gCAAgCC,IAAhC,CAAqChH,QAArC,CAFD,EAGE;AACD,YAAM,IAAI8B,YAAJ,CACL,sIADK,EAEL,MAFK,EAGL,MAHK,CAAN;AAGC;;AAIF,SAAK9B,QAAL,GAAgBA,QAAhB;AACA,SAAKT,WAAL,GAAmBmH,QAAQnH,WAA3B;AACA,SAAK0H,MAAL,GAAcP,QAAQO,MAAtB;AACA,SAAKC,aAAL,GAAqBR,QAAQQ,aAA7B;;AAEA,QAAIR,QAAQ/E,GAAZ,EAAiB;AAChB,WAAKwF,mBAAL,CAAyBT,QAAQ/E,GAAjC;AAAiC;;AAGlC,QAAI,OAAO+E,QAAQU,KAAf,KAAyB,UAA7B,EAAyC;AACxC,WAAKC,OAAL,GAAeX,QAAQU,KAAvB;AAAuB,KADxB,MACwB,IACb,OAAOE,WAAWF,KAAlB,KAA4B,UADf,EAC2B;AAClD,WAAKC,OAAL,GAAeC,WAAWF,KAA1B;AAA0B,KAFH,MAGjB;AACN,YAAM,IAAItF,YAAJ,CACL,gMADK,EAEL,MAFK,EAGL,MAHK,CAAN;AAGC;;AAKF,QAAI,KAAKuF,OAAL,KAAiBC,WAAWF,KAAhC,EAAuC;AACtC,WAAKC,OAAL,GAAe,KAAKA,OAAL,CAAaE,IAAb,CAAkBD,UAAlB,CAAf;AAAiC;;AAGlC,SAAKE,YAAL,GAAoB,KAAKA,YAAL,CAAkBD,IAAlB,CAAuB,IAAvB,CAApB;AAA2C;;;;WAiB5C,8BAA2B;AAC1B,WAAKE,QAAL,CAAcb,mBAAd,GAAoC,IAApC;AAAoC;;;WAoBrC,mCAAqDc,GAArD,EAAmE;AAClE,WAAKD,QAAL,CAAcE,WAAd,GAA4BD,GAA5B;AACA,WAAKD,QAAL,CAAcb,mBAAd,GAAoC,IAApC;AAAoC;;;WAgBrC,+BAA4B;AAC3B,WAAKa,QAAL,CAAcb,mBAAd,GAAoC,KAApC;AAAoC;;;;4EAAA,iBAqBpC1G,UArBoC,EAsBpCC,MAtBoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAwBlB,KAAKJ,aAAL,iCAAwBI,MAAxB;AAAgCD;AAAhC,mBAxBkB;;AAAA;AAwB9BE,mBAxB8B;AAAA;AAAA,uBA0BvB,KAAKgH,KAAL,CAAsChH,GAAtC,EAA2CD,MAA3C,CA1BuB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;0EA0BoB,kBAkBxDA,MAlBwD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAoBtC,KAAKJ,aAAL,CAAmBI,MAAnB,CApBsC;;AAAA;AAoBlDC,mBApBkD;AAAA;AAAA,uBAsB3C,KAAKgH,KAAL,CAAsChH,GAAtC,EAA2CD,MAA3C,CAtB2C;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EAsBA,kBAkBxDA,MAlBwD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAoBtC,KAAKJ,aAAL,CAAmBI,MAAnB,CApBsC;;AAAA;AAoBlDC,mBApBkD;AAAA;AAAA,uBAqBnC,KAAKgH,KAAL,CAAsChH,GAAtC,EAA2CD,MAA3C,CArBmC;;AAAA;AAqBlDsC,sBArBkD;AAuBlDmF,2BAvBkD,GAuBpCnF,OAAOoF,OAAP,CAAe,CAAf,CAvBoC;;AAAA,qBAyBpDD,WAzBoD;AAAA;AAAA;AAAA;;AAAA,kDA0BhDA,WA1BgD;;AAAA;AAAA,sBA6BlD,IAAI9F,YAAJ,CAAiB,4BAAjB,EAA+C1B,GAA/C,EAAoD,MAApD,CA7BkD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;wFA6BE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAyB1DD,sBAzB0D,8DA2B3C,EA3B2C;AAAA,gCA6BZA,MA7BY,CA6BlD2H,KA7BkD,EA6BlDA,KA7BkD,8BA6B1CC,QA7B0C,kBA6B7BC,YA7B6B,4BA6BZ7H,MA7BY;AA8BpD8H,8BA9BoD,mCA+BtDD,YA/BsD;AAgCzDE,4BAAUF,aAAaE,QAAb,IAAyBlC;AAhCsB;AAmCpDmC,yBAnCoD,GAmC3B,EAnC2B;;AAAA;AAAA,sBAuCxD,EAACC,YAAD,IAAiBA,aAAaC,SAA9B,KACDF,UAAUnE,MAAV,GAAmB8D,KAxCsC;AAAA;AAAA;AAAA;;AA0CnDQ,oBA1CmD,GA0C5CF,eAAeA,aAAaE,IAAb,GAAoB,CAAnC,GAAuC,MA1CK;AAAA;AAAA,uBA4CpC,KAAKC,GAAL,iCAAyBN,cAAzB;AAAyCK;AAAzC,mBA5CoC;;AAAA;AA4CzDF,4BA5CyD;AA6CzDD,0BAAUK,IAAV,qCAAkBJ,aAAaP,OAA/B;;AA7CyD,qBA+CrDO,aAAaC,SA/CwC;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAgDlD,IAAII,OAAJ,CAAY,UAACC,GAAD;AAAA,yBAASC,WAAWD,GAAX,EAAgBxC,mBAAhB,CAAT;AAAA,iBAAZ,CAhDkD;;AAAA;AAAA;AAAA;;AAAA;AAAA,kDAoDnDiC,UAAUrF,KAAV,CAAgB,CAAhB,EAAmBgF,KAAnB,CApDmD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;8EAoDhC,kBAwB1B5F,EAxB0B,EAyB1B/B,MAzB0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA2Bb,KAAKyI,QAAL,CACZzH,iBAAiBhB,MAAjB,EAAyBG,UAAU8D,EAAV,CAAa,aAAb,EAA4BlC,EAA5B,CAAzB,CADY,CA3Ba;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EA4B4B,kBA4BtD2G,GA5BsD,EA6BtD1I,MA7BsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA+BzC,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyBG,UAAUiE,EAAV,CAAa,aAAb,EAA4BsE,GAA5B,CAAzB,CADY,CA/ByC;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;kFAgCA,kBA6BtDA,GA7BsD,EA8BtD1I,MA9BsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAgCzC,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyBG,UAAUiE,EAAV,CAAa,aAAb,EAA4BsE,GAA5B,CAAzB,CADY,CAhCyC;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EAiCA,kBA0BtDzC,YA1BsD,EA2BtD2C,GA3BsD,EA4BtD5I,MA5BsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA8BzC,KAAKyI,QAAL,CACZzH,iBAAiBhB,MAAjB,EAAyB,CACxBgG,cAAcC,YAAd,CADwB,EAExB9F,UAAU8D,EAAV,cAAmBgC,YAAnB,WAAuC2C,GAAvC,CAFwB,CAAzB,CADY,CA9ByC;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;gFAiCb,kBA8BzC3C,YA9ByC,EA+BzC4C,IA/ByC,EAgCzC7I,MAhCyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAkC5B,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyB,CACxBgG,cAAcC,YAAd,CADwB,EAExB9F,UAAUiE,EAAV,cAAmB6B,YAAnB,WAAuC4C,IAAvC,CAFwB,CAAzB,CADY,CAlC4B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;mFAqCA,mBA+BzC5C,YA/ByC,EAgCzC4C,IAhCyC,EAiCzC7I,MAjCyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAmC5B,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyB,CACxBgG,cAAcC,YAAd,CADwB,EAExB9F,UAAUiE,EAAV,cAAmB6B,YAAnB,WAAuC4C,IAAvC,CAFwB,CAAzB,CADY,CAnC4B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;gFAsCA,mBA0BzC5C,YA1ByC,EA2BzCjG,MA3ByC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA6B5B,KAAKyI,QAAL,CACZzH,iBAAiBhB,MAAjB,EAAyBgG,cAAcC,YAAd,CAAzB,CADY,CA7B4B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;gFA8BD,mBAuBxCA,YAvBwC,EAwBxCjG,MAxBwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA0B3B,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyBgG,cAAcC,YAAd,CAAzB,CADY,CA1B2B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;mFA2BA,mBAsBxCA,YAtBwC,EAuBxCjG,MAvBwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAyB3B,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyBgG,cAAcC,YAAd,CAAzB,CADY,CAzB2B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EA0BA,mBAsBxC6C,GAtBwC,EAuBxC9I,MAvBwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAyB3B,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyBoG,kBAAkB0C,GAAlB,CAAzB,CADY,CAzB2B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;kFA0BI,mBAsB5CA,GAtB4C,EAuB5C9I,MAvB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAyB/B,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyBoG,kBAAkB0C,GAAlB,CAAzB,CADY,CAzB+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;oFA0BA,mBAqB5C3C,IArB4C,EAsB5CnG,MAtB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAwB/B,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyBkG,kBAAkBC,IAAlB,CAAzB,CADY,CAxB+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;uFAyBA,mBAuB5CA,IAvB4C,EAwB5CnG,MAxB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA0B/B,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyBkG,kBAAkBC,IAAlB,CAAzB,CADY,CA1B+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;oFA2BA,mBAqB5CA,IArB4C,EAsB5CnG,MAtB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAwB/B,KAAKoI,GAAL,CACZpH,iBAAiBhB,MAAjB,EAAyBoG,kBAAkBD,IAAlB,CAAzB,CADY,CAxB+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;uFAyBA,mBAuB5CA,IAvB4C,EAwB5CnG,MAxB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBA0B/B,KAAK2I,iBAAL,CACZ3H,iBAAiBhB,MAAjB,EAAyBoG,kBAAkBD,IAAlB,CAAzB,CADY,CA1B+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;oFA2BA,mBAUzBnG,MAVyB;AAAA;AAAA;AAAA;AAAA;AAAA;AActCC,mBAdsC,GAchC,IAAIC,GAAJ,CAAQ,KAAKL,QAAb,CAdgC;;AAgB5C,oBAAI,KAAKT,WAAT,EAAsB;AACrBa,sBAAIG,YAAJ,CAAiBU,GAAjB,CAAqB,cAArB,EAAqC,KAAK1B,WAA1C;AAA0C;;AAjBC;AAAA,uBAoB/B,KAAK6H,KAAL,CAAgChH,IAAIc,QAAJ,EAAhC,EAAgDf,MAAhD,CApB+B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;8EAoBiB,mBAYhDA,MAZgD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAapC,KAAK+I,aAAL,CAAmB/I,MAAnB,CAboC;;AAAA;AAavDgJ,0BAbuD;AAAA,mDAetDA,WAAWzH,IAf2C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;iFAe3C,mBAUFQ,EAVE,EAUU/B,MAVV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAWC,KAAKiJ,OAAL,CAAajJ,MAAb,CAXD;;AAAA;AAWZuB,oBAXY;AAAA,mDAaXO,YAAYP,IAAZ,EAAkBQ,EAAlB,CAbW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;oFAaO,mBAWzBE,KAXyB,EAYzBjC,MAZyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAcN,KAAKiJ,OAAL,CAAajJ,MAAb,CAdM;;AAAA;AAcnBuB,oBAdmB;AAAA,mDAgBlBS,eAAeT,IAAf,EAAqBU,KAArB,CAhBkB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;mFAgBG,mBASVjC,MATU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAUT,KAAKiJ,OAAL,CAAajJ,MAAb,CAVS;;AAAA;AAUtBuB,oBAVsB;AAAA,mDAYrBK,cAAcL,IAAd,CAZqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;kFAYP,mBASJvB,MATI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAUF,KAAKiJ,OAAL,CAAajJ,MAAb,CAVE;;AAAA;AAUfuB,oBAVe;AAAA,mDAYdA,KAAK9B,MAAL,CAAY,UAAC+B,GAAD;AAAA,yBAAS,CAACA,IAAIK,WAAd;AAAA,iBAAZ,CAZc;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;qFAYY,mBAWjCE,EAXiC,EAYjC/B,MAZiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAcV,KAAKkJ,WAAL,CAAiBlJ,MAAjB,CAdU;;AAAA;AAc3BmJ,wBAd2B;AAAA,mDAgB1BrH,YAAYqH,QAAZ,EAAsBpH,EAAtB,CAhB0B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;wFAgBJ,mBAW7BE,KAX6B,EAY7BjC,MAZ6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAcN,KAAKkJ,WAAL,CAAiBlJ,MAAjB,CAdM;;AAAA;AAcvBmJ,wBAduB;AAAA,mDAgBtBnH,eAAemH,QAAf,EAAyBlH,KAAzB,CAhBsB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;8EAgBG,mBAQnBjC,MARmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAUR,KAAKoJ,uBAAL,CAA6B,MAA7B,EAAqCpJ,MAArC,CAVQ;;AAAA;AAUzBqJ,wBAVyB;AAAA;AAAA,uBAYlB,KAAKpC,KAAL,CAAqBoC,SAASC,MAA9B,CAZkB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uBAcN,KAAKP,aAAL,CAAmB/I,MAAnB,CAdM;;AAAA;AAczBgJ,0BAdyB;AAAA,mDAgBxBA,WAAW7C,IAhBa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;qFAgBb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qFAc0B,EAd1B,EAYnBoD,MAZmB,QAYnBA,MAZmB,EAahBvJ,MAbgB;AAAA,gCAePA,OAAOwB,GAfA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAec,KAAKgI,oBAAL,EAfd;;AAAA;AAAA;;AAAA;AAebhI,mBAfa;AAAA,gCAiBlBxB,OAAOyJ,oBAjBW;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAkBX,KAAKC,mBAAL,CAAyB;AAAEH;AAAF,iBAAzB,CAlBW;;AAAA;AAAA,gDAkB2BE,oBAlB3B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA,gCAmBlB,MAnBkB;;AAAA;AAgBbA,oCAhBa;AAAA,mDAqBZ7J,eAAc,KAAKC,QAAnB,gDACH,KAAKkH,aADF,GAEH/G,MAFG;AAGNwB,0BAHM;AAINiI,4DAJM;AAKN3C,0BAAQ9G,OAAO8G,MAAP,IAAiB,KAAKA,MALxB;AAMN1H,+BAAaY,OAAOZ,WAAP,IAAsB,KAAKA;AANlC,mBArBY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;wFA2BsB,mBAwBzCU,IAxByC;AAAA;;AAAA;AAAA;AAAA;AAAA;AA0BrC6J,0BA1BqC,GA0BxB7J,KAAK6J,UA1BmB;AA2BrCC,4BA3BqC,GA2BtB9J,KAAK8J,YA3BiB;;AA6BzC,oBAAI,OAAOzC,WAAW0C,QAAlB,KAA+B,WAAnC,EAAgD;AACzCzJ,8BADyC,GAC1B,IAAI0J,eAAJ,CAAoB3C,WAAW0C,QAAX,CAAoBE,MAAxC,CAD0B;AAG/CJ,+BAAaA,cAAcvJ,aAAagI,GAAb,CAAiB,YAAjB,CAAd,IAAgD,MAA7D;AACAwB,iCAAeA,gBAAgBxJ,aAAagI,GAAb,CAAiB,OAAjB,CAAhB,IAA6C,MAA5D;AAA4D,iBAJ7D,MAI6D,IAClD,WAAKd,QAAL,CAAcE,WAAd,wBAA2BxE,KADuB,EAChB;AAC5C2G,+BACCA,cAAe,KAAKrC,QAAL,CAAcE,WAAd,CAA0BxE,KAA1B,CAAgCgH,UADhD;AAEAJ,iCACCA,gBAAiB,KAAKtC,QAAL,CAAcE,WAAd,CAA0BxE,KAA1B,CAAgCiH,KADlD;AACkD;;AAtCV,sBAyCrCN,cAAc,IAzCuB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBA0CjB,KAAKO,OAAL,CAAaP,UAAb,EAAyB;AAC/CJ,0BAAQzJ,KAAKyJ,MADkC;AAE/C/H,uBAAKoI,YAF0C;AAG/CO,wBAAM;AAHyC,iBAAzB,CA1CiB;;AAAA;AA0ClCC,wBA1CkC;AAAA,mDAkDjCC,SAASC,MAAT,CAAgBF,QAAhB,EAA0BtK,KAAKyK,YAA/B,CAlDiC;;AAAA;AAAA,mDAoDjCzK,KAAK0K,UApD4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAoE1C,8BAA2B;AAC1B,WAAKlD,QAAL,CAAcd,IAAd,GAAqB;AAAA;AAArB;AAAqB;;;WAkBtB,qCAA4BiE,SAA5B,EAAqD;AACpD,WAAKnD,QAAL,mCACI,KAAKA,QADT;AAECd,cAAM;AAAA;AAFP;AAGCiE;AAHD;AAGC;;;WAmBF,wCAA+BC,YAA/B,EAA2D;AAC1D,WAAKpD,QAAL,mCACI,KAAKA,QADT;AAECd,cAAM;AAAA;AAFP;AAGCkE;AAHD;AAGC;;;WAoBF,6BAAoBlJ,GAApB,EAAiD;AAChD,WAAK8F,QAAL,mCACI,KAAKA,QADT;AAECd,cAAM;AAAA;AAFP;AAGChF;AAHD;AAGC;;;;mFAAA,mBAgCDmJ,KAhCC,EAiCDC,IAjCC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAmC8B,KAAKlB,mBAAL,EAnC9B;;AAAA;AAmCKmB,gCAnCL;AAAA;AAAA,uBAoCiB,KAAKrB,oBAAL,EApCjB;;AAAA;AAoCKhI,mBApCL;AAsCKsJ,kCAtCL;AAuCA,iCAAetJ,GAvCf;AAwCA,mDACCqJ,iBAAiBpB,oBAAjB,IAAyC,EAzC1C;AA0CAsB,iCAAe,KAAK3L,WAAL,mBAA4B,KAAKA,WAAjC,IAAiD;AA1ChE,mBA8CIwL,OAAQA,KAAKI,OAAb,GAAkD,EA9CtD;AAoDKA,uBApDL,GAoDuC,EApDvC;;AAqDD,qBAAWC,GAAX,IAAkBH,kBAAlB,EAAsC;AACrC,sBAAIA,mBAAmBG,GAAnB,CAAJ,EAA6B;AAC5BD,4BAAQC,IAAIC,WAAJ,EAAR,IACCJ,mBAAmBG,GAAnB,CADD;AACoB;AAAA;;AAOhBhL,mBA/DL,GA+DW,IAAIC,GAAJ,CAIXyK,KAJW,CA/DX;AAqEK3H,qBArEL,GAqEa/C,IAAIG,YAAJ,CAAiBgI,GAAjB,CAAqB,OAArB,CArEb;;AAsED,oBAAIpF,KAAJ,EAAW;AACV/C,sBAAIG,YAAJ,CAAiBU,GAAjB,CAAqB,OAArB,EAA8BiC,mBAAmBC,KAAnB,CAA9B;AAAiD;;AAvEjD;AAAA,uBA0Ea,KAAKkE,OAAL,CAAajH,IAAIc,QAAJ,EAAb,kCACV6J,IADU;AAEbI;AAFa,mBA1Eb;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;0FA4EA,mBAUDhL,MAVC;AAAA;AAAA;AAAA;AAAA;AAAA,sBAaA,CAAC,KAAK6K,gBAAN,IACAvH,KAAK6H,GAAL,MAAc,KAAKC,0BAdnB;AAAA;AAAA;AAAA;;AAgBA,qBAAKA,0BAAL,GAAkC9H,KAAK6H,GAAL,KAAarF,oBAA/C;AAhBA;AAAA,uBAiB8B,KAAKiD,aAAL,CAAmB/I,MAAnB,CAjB9B;;AAAA;AAiBA,qBAAK6K,gBAjBL;;AAAA;AAAA,mDAoBM,KAAKA,gBApBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;8FAoBW,mBAaZtK,IAbY,EAcZP,MAdY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAgBmB,KAAK0J,mBAAL,CAAyB1J,MAAzB,CAhBnB;;AAAA;AAgBN6K,gCAhBM;AAiBNQ,oBAjBM,GAiBCR,iBAAiBS,KAAjB,CAAuB/K,IAAvB,CAjBD;;AAAA,oBAmBP8K,IAnBO;AAAA;AAAA;AAAA;;AAAA,sBAoBL,IAAI1J,YAAJ,4BACcpB,IADd,4BAEL,MAFK,EAGL,MAHK,CApBK;;AAAA;AAAA,mDA2BL8K,IA3BK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;2FA2BL,mBAwB2BrL,MAxB3B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAyBH,KAAKsH,QAAL,CAAcb,mBAzBX;AAAA;AAAA;AAAA;;AA0BF8E,0BA1BE,GA0B+B,MA1B/B;;AA4BN,oBAAI,iBAAWnB,QAAX,wBAAqB3H,MAAzB,EAAiC;AAChC8I,+BAAazI,UAAU0I,OAAV,EAA0BrE,WAAWiD,QAAX,CAAoB3H,MAA9C,CAAb;AAA2D,iBAD5D,MAC4D,IACjD,iBAAK6E,QAAL,CAAcE,WAAd,wBAA2BwD,OAA3B,wBAAoCvI,MADa,EACL;AACtD8I,+BAAazI,UACZ0I,OADY,EAEZ,KAAKlE,QAAL,CAAcE,WAAd,CAA0BwD,OAA1B,CAAkCvI,MAFtB,CAAb;AAEmC;;AAjC9B,qBAqCF8I,UArCE;AAAA;AAAA;AAAA;;AAAA,mDAsCEA,UAtCF;;AAAA;AAAA;AAAA,uBA0CwB,KAAK7B,mBAAL,CAAyB1J,MAAzB,CA1CxB;;AAAA;AA0CD6K,gCA1CC;AA4CDY,2BA5CC,GA4Ca,KAAKnE,QAAL,CAAcd,IA5C3B;;AAAA,sBA6CHiF,gBAAgB;AAAA;AA7Cb;AAAA;AAAA;AAAA;;AAAA,mDA8CC3J,YAAY+I,iBAAiBtJ,IAA7B,EAAmC,KAAK+F,QAAL,CAAcmD,SAAjD,EAA4DjJ,GA9C7D;;AAAA;AAAA,sBA+CIiK,gBAAgB;AAAA;AA/CpB;AAAA;AAAA;AAAA;;AAAA,mDAgDCzJ,eAAe6I,iBAAiBtJ,IAAhC,EAAsC,KAAK+F,QAAL,CAAcoD,YAApD,EACLlJ,GAjDI;;AAAA;AAAA,sBAkDIiK,gBAAgB;AAAA;AAlDpB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAmDYvK,UAAU,KAAKoG,QAAL,CAAc9F,GAAxB,GAnDZ;;AAAA;AAmDA+G,mBAnDA;;AAAA,sBAqDF,OAAOA,GAAP,KAAe,QArDb;AAAA;AAAA;AAAA;;AAAA,mDAsDEA,GAtDF;;AAAA;AAAA,mDA0DA3G,cAAciJ,iBAAiBtJ,IAA/B,EAAqCC,GA1DrC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;4EA0DqC,mBAe5CvB,GAf4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkB5CD,sBAlB4C,iEAkBtB,EAlBsB;AAAA;AAAA,uBA0B1B,KAAKkH,OAAL,CAAajH,GAAb,EAAkB;AACnCsJ,0BAAQvJ,OAAOuJ;AADoB,iBAAlB,CA1B0B;;AAAA;AA0BtChB,mBA1BsC;AAAA;AAAA;AAAA,uBAmC9BA,IAAImD,IAAJ,EAnC8B;;AAAA;AAmC3CA,oBAnC2C;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,sBAuCvCnD,IAAIoD,MAAJ,KAAe,GAvCwB;AAAA;AAAA;AAAA;;AAAA,sBAwCpC,IAAIC,aAAJ,sDACwC,KAAK/L,QAD7C,gDAELI,GAFK,EAGL,MAHK,CAxCoC;;AAAA;AAAA,sBA8CpC,IAAI0B,YAAJ,CAAiB,MAAjB,EAA4B1B,GAA5B,EAAiC,MAAjC,CA9CoC;;AAAA;AAAA,gCAkDpCsI,IAAIoD,MAlDgC;AAAA,oDAoDtC,GApDsC,0BA2DtC,GA3DsC,0BAkEtC,GAlEsC,0BAsEtC,GAtEsC;AAAA;;AAAA;AAAA,mDAqDnCD,IArDmC;;AAAA;AAAA,sBA4DpC,IAAIG,YAAJ,CAAiBH,KAAKvK,OAAtB,EAA+BlB,GAA/B,EAAoCyL,IAApC,CA5DoC;;AAAA;AAAA,sBAuEpC,IAAII,cAAJ,CACL,WAAWJ,IAAX,GAAkBA,KAAKK,KAAvB,GAA+BL,KAAKvK,OAD/B,EAELlB,GAFK,EAGLyL,IAHK,CAvEoC;;AAAA;AAAA,sBA+EtC,IAAI/J,YAAJ,CAAiB,MAAjB,EAA4B1B,GAA5B,EAAiCyL,IAAjC,CA/EsC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;ICr7CjC3L,aAAaI;IAKb6L,aAAa7L","names":["getEndpoint","repositoryName","getGraphQLEndpoint","castArray","a","Array","isArray","RENAMED_PARAMS","accessToken","castOrderingToString","ordering","field","direction","filter","Boolean","join","buildQueryURL","endpoint","args","predicates","params","url","URL","predicate","searchParams","append","k","name","value","scopedValue","v","map","JSON","stringify","set","toString","appendPredicates","objWithPredicates","castThunk","message","response","Error","findRef","refs","ref","find","ref2","PrismicError","findMasterRef","isMasterRef","findRefByID","id","findRefByLabel","label","readValue","replace","parse","cookieString","result","cookies","split","cookie","parts","slice","getAll","cookieStore","getCookie","minifyGraphQLQuery","query","_chars","_spaces","brackets","preview","formatValue","Date","getTime","pathWithArgsPredicate","fn","path","formattedArgs","joiner","length","pathPredicate","predicateFn","argsPredicate","at","not","any","in","fulltext","has","missing","similar","geopointNear","numberLessThan","numberGreaterThan","numberInRange","dateAfter","dateBefore","dateBetween","dateDayOfMonth","dateDayOfMonthAfter","dateDayOfMonthBefore","dateDayOfWeek","dateDayOfWeekAfter","dateDayOfWeekBefore","dateMonth","dateMonthAfter","dateMonthBefore","dateYear","dateHour","dateHourAfter","dateHourBefore","MAX_PAGE_SIZE","REPOSITORY_CACHE_TTL","GET_ALL_QUERY_DELAY","typePredicate","documentType","everyTagPredicate","tags","someTagsPredicate","createClient","Client","options","mode","autoPreviewsEnabled","process","env","NODE_ENV","test","routes","defaultParams","queryContentFromRef","fetch","fetchFn","globalThis","bind","graphqlFetch","refState","req","httpRequest","firstResult","results","limit","Infinity","actualParams","resolvedParams","pageSize","documents","latestResult","next_page","page","get","push","Promise","res","setTimeout","getFirst","ids","dangerouslyGetAll","uid","uids","tag","getRepository","repository","getRefs","getReleases","releases","getCachedRepositoryForm","tagsForm","action","signal","getResolvedRefString","integrationFieldsRef","getCachedRepository","documentID","previewToken","location","URLSearchParams","search","documentId","token","getByID","lang","document","prismicH","asLink","linkResolver","defaultURL","releaseID","releaseLabel","input","init","cachedRepository","unsanitizedHeaders","Authorization","headers","key","toLowerCase","now","cachedRepositoryExpiration","form","forms","previewRef","cookie.preview","refModeType","json","status","NotFoundError","ParsingError","ForbiddenError","error","Predicates"],"sources":["/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/getEndpoint.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/getGraphQLEndpoint.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/castArray.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/buildQueryURL.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/appendPredicates.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/castThunk.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/PrismicError.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/findRef.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/findMasterRef.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/findRefByID.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/findRefByLabel.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/getCookie.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/lib/minifyGraphQLQuery.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/cookie.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/ForbiddenError.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/NotFoundError.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/ParsingError.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/predicate.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/client.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/client/src/index.ts"],"sourcesContent":["/**\n * Get a repository's Prismic REST API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` =>\n\t`https://${repositoryName}.cdn.prismic.io/api/v2` as const;\n","/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` =>\n\t`https://${repositoryName}.cdn.prismic.io/graphql` as const;\n","/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => (Array.isArray(a) ? a : [a]);\n","import { castArray } from \"./lib/castArray\";\n\nimport { ValueOf, Ordering, Route } from \"./types\";\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#pagesize}\n\t */\n\tpageSize?: number;\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#page}\n\t */\n\tpage?: number;\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in the list.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#after}\n\t */\n\tafter?: string;\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetch}\n\t */\n\tfetch?: string | string[];\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetchlinks}\n\t */\n\tfetchLinks?: string | string[];\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content Relationships.\n\t *\n\t * {@link https://prismic.io/docs/technologies/graphquery-rest-api}\n\t */\n\tgraphQuery?: string;\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#lang}\n\t */\n\tlang?: string;\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#orderings}\n\t */\n\torderings?: Ordering | string | (Ordering | string)[];\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[];\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n\t */\n\tref: string;\n\n\t/**\n\t * Ref used to populate Integration Fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/integration-fields}\n\t */\n\tintegrationFieldsRef?: string;\n\n\t/**\n\t * One or more predicates to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n\t */\n\tpredicates?: string | string[];\n};\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const;\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>;\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string =>\n\ttypeof ordering === \"string\"\n\t\t? ordering\n\t\t: [\n\t\t\t\tordering.field,\n\t\t\t\tordering.direction === \"desc\" ? ordering.direction : undefined,\n\t\t  ]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" \");\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams;\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { predicates, ...params } = args;\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`);\n\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`);\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ??\n\t\t\tk) as ValidParamName;\n\n\t\tlet value = params[k as keyof typeof params];\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name];\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\");\n\n\t\t\t\tvalue = `[${v}]`;\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]));\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(name, castArray(value).join(\",\"));\n\t\t}\n\t}\n\n\treturn url.toString();\n};\n","import { castArray } from \"./castArray\";\n\ninterface WithPredicates {\n\tpredicates?: string | string[];\n}\n\n/**\n * Adds one or more predicates to an object with a `predicates` property.\n * Appended predicates are added to the end of the existing list.\n *\n * @typeParam T - Object to which predicates will be append.\n * @param objWithPredicates - Object to append predicates on the `predicates` property.\n * @param predicates - One or more predicates to append.\n *\n * @returns The object with the appended predicates.\n */\nexport const appendPredicates = <T extends WithPredicates>(\n\tobjWithPredicates: T = {} as T,\n\tpredicates: string | string[],\n) => {\n\treturn {\n\t\t...objWithPredicates,\n\t\tpredicates: [\n\t\t\t...(objWithPredicates.predicates || []),\n\t\t\t...castArray(predicates),\n\t\t],\n\t};\n};\n","/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) =>\n\ttypeof a === \"function\" ? (a as () => A) : () => a;\n","export class PrismicError<Response> extends Error {\n\turl?: string;\n\tresponse: Response;\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message);\n\n\t\tthis.url = url;\n\t\tthis.response = response;\n\t}\n}\n","import * as prismicT from \"@prismicio/types\";\n\nimport { PrismicError } from \"../PrismicError\";\n\n/**\n * Returns the first ref from a list that passes a predicate (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param predicate - A function that determines if a ref from the list matches\n *   the criteria.\n *\n * @returns The first matching ref.\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (\n\trefs: prismicT.Ref[],\n\tpredicate: (ref: prismicT.Ref) => boolean,\n): prismicT.Ref => {\n\tconst ref = refs.find((ref) => predicate(ref));\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined);\n\t}\n\n\treturn ref;\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: prismicT.Ref[]): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef);\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: prismicT.Ref[], id: string): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.id === id);\n};\n","import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (\n\trefs: prismicT.Ref[],\n\tlabel: string,\n): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.label === label);\n};\n","/**\n * The following code is a modifed version of `es-cookie` taken from\n * https://github.com/theodorejb/es-cookie\n *\n * Copyright 2017 Theodore Brown\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.*\n */\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\");\n};\n\nexport const parse = (cookieString: string): { [name: string]: string } => {\n\tconst result: { [name: string]: string } = {};\n\tconst cookies = cookieString.split(\"; \");\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\");\n\t\tconst value = parts.slice(1).join(\"=\");\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\");\n\t\tresult[name] = readValue(value);\n\t}\n\n\treturn result;\n};\n\nconst getAll = (cookieStore: string): { [name: string]: string } =>\n\tparse(cookieStore);\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param Name - Of the cookie.\n * @param cookieStore - The stringified cookie store from which to read the cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getCookie = (\n\tname: string,\n\tcookieStore: string,\n): string | undefined => getAll(cookieStore)[name];\n","/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t);\n};\n","/**\n * The well-known name of the cookie used to store a Prismic preview session's ref.\n */\nexport const preview = \"io.prismic.preview\";\n","import { PrismicError } from \"./PrismicError\";\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string;\n\tmessage: string;\n};\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string;\n};\n\nexport class ForbiddenError extends PrismicError<\n\tForbiddenErrorRepositoryAPIResponse | ForbiddenErrorQueryAPIResponse\n> {}\n","import { PrismicError } from \"./PrismicError\";\n\nexport class NotFoundError extends PrismicError<undefined> {}\n","import { PrismicError } from \"./PrismicError\";\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\";\n\tmessage: string;\n\tline: number;\n\tcolumn: number;\n\tid: number;\n\tlocation: string;\n};\n\nexport class ParsingError extends PrismicError<ParsingErrorAPIResponse> {}\n","/**\n * Formats the value of a predicate element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`;\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`;\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`;\n\t}\n\n\treturn `${value}`;\n};\n\n/**\n * Creates a predicate builder function for predicates with a path and arguments.\n *\n * @typeParam Args - Arguments for the predicate.\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathWithArgsPredicate = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \");\n\t\tconst joiner = path && args.length ? \", \" : \"\";\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`;\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only a path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathPredicate = (name: string) => {\n\tconst predicateFn = pathWithArgsPredicate(name);\n\n\t/**\n\t * @param path - Path for the predicate.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn predicateFn(path);\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only arguments and no path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst argsPredicate = <Args extends unknown[]>(name: string) => {\n\tconst predicateFn = pathWithArgsPredicate<Args>(name);\n\n\t/**\n\t * @param args - Arguments for the predicate.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn predicateFn(\"\", ...args);\n\t};\n\n\treturn fn;\n};\n\n/**\n * The default arguments allowed by predicates.\n */\ntype DefaultPredicateArgs = [value: string | number | (string | number)[]];\n\nexport const predicate = {\n\t/**\n\t * The `at` predicate checks that the path matches the described value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#at}\n\t */\n\tat: pathWithArgsPredicate<DefaultPredicateArgs>(\"at\"),\n\n\t/**\n\t * The `not` predicate checks that the path doesn't match the provided value\n\t * exactly. It takes a single value as the argument.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#not}\n\t */\n\tnot: pathWithArgsPredicate<DefaultPredicateArgs>(\"not\"),\n\n\t/**\n\t * The `any` predicate takes an array of values. It works exactly the same way\n\t * as the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#any}\n\t */\n\tany: pathWithArgsPredicate<DefaultPredicateArgs>(\"any\"),\n\n\t/**\n\t * The `in` predicate is used specifically to retrieve an array of documents\n\t * by their IDs or UIDs. This predicate is much more efficient at this than\n\t * the any predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#in}\n\t */\n\tin: pathWithArgsPredicate<DefaultPredicateArgs>(\"in\"),\n\n\t/**\n\t * The `fulltext` predicate provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom type’s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#fulltext}\n\t */\n\tfulltext: pathWithArgsPredicate<DefaultPredicateArgs>(\"fulltext\"),\n\n\t/**\n\t * The `has` predicate checks whether a fragment has a value. It will return\n\t * all the documents of the specified type that contain a value for the\n\t * specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#has}\n\t */\n\thas: pathPredicate(\"has\"),\n\n\t/**\n\t * The `missing` predicate checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#missing}\n\t */\n\tmissing: pathPredicate(\"missing\"),\n\n\t/**\n\t * The `similar` predicate takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#similar}\n\t */\n\tsimilar: argsPredicate<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` predicate checks that the value in the path is within\n\t * the radius of the given coordinates.\n\t *\n\t * This predicate will only work for a GeoPoint field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#near}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsPredicate<\n\t\t\t[latitude: number, longitude: number, radius: number]\n\t\t>(\"geopoint.near\"),\n\n\t/**\n\t * The `number.lt` predicate checks that the value in the number field is less\n\t * than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#lt-less-than}\n\t */\n\tnumberLessThan: pathWithArgsPredicate<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` predicate checks that the value in the number field is\n\t * greater than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#gt-greater-than}\n\t */\n\tnumberGreaterThan: pathWithArgsPredicate<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` predicate checks that the value in the path is within\n\t * the two values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#inrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsPredicate<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` predicate checks that the value in the path is after the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#after}\n\t */\n\tdateAfter:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` predicate checks that the value in the path is before the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#before}\n\t */\n\tdateBefore:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` predicate checks that the value in the path is within\n\t * the date values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#between}\n\t */\n\tdateBetween:\n\t\tpathWithArgsPredicate<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` predicate checks that the value in the path is\n\t * equal to the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonth}\n\t */\n\tdateDayOfMonth: pathWithArgsPredicate<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` predicate checks that the value in the path\n\t * is after the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthafter}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` predicate checks that the value in the path\n\t * is before the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthbefore}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` predicate checks that the value in the path is equal\n\t * to the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweek}\n\t */\n\tdateDayOfWeek:\n\t\tpathWithArgsPredicate<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` predicate checks that the value in the path is\n\t * after the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekafter}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before predicate checks that the value in the path is\n\t * before the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekbefore}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` predicate checks that the value in the path occurs in the\n\t * month value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#month}\n\t */\n\tdateMonth: pathWithArgsPredicate<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` predicate checks that the value in the path occurs\n\t * in any month after the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthafter}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` predicate checks that the value in the path occurs\n\t * in any month before the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthbefore}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` predicate checks that the value in the path occurs in the\n\t * year value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#year}\n\t */\n\tdateYear: pathWithArgsPredicate<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` predicate checks that the value in the path occurs within\n\t * the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hour}\n\t */\n\tdateHour: pathWithArgsPredicate<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` predicate checks that the value in the path occurs\n\t * after the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourafter}\n\t */\n\tdateHourAfter: pathWithArgsPredicate<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` predicate checks that the value in the path occurs\n\t * before the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourbefore}\n\t */\n\tdateHourBefore: pathWithArgsPredicate<[hour: number]>(\"date.hour-before\"),\n};\n","import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\n\nimport { appendPredicates } from \"./lib/appendPredicates\";\nimport { castArray } from \"./lib/castArray\";\nimport { castThunk } from \"./lib/castThunk\";\nimport { findMasterRef } from \"./lib/findMasterRef\";\nimport { findRefByID } from \"./lib/findRefByID\";\nimport { findRefByLabel } from \"./lib/findRefByLabel\";\nimport { getCookie } from \"./lib/getCookie\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\";\n\nimport * as cookie from \"./cookie\";\nimport { AbortSignalLike, FetchLike, HttpRequestLike } from \"./types\";\nimport { ForbiddenError } from \"./ForbiddenError\";\nimport { NotFoundError } from \"./NotFoundError\";\nimport { ParsingError } from \"./ParsingError\";\nimport { PrismicError } from \"./PrismicError\";\nimport { buildQueryURL, BuildQueryURLArgs } from \"./buildQueryURL\";\nimport { predicate } from \"./predicate\";\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100;\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000;\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500;\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean;\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike;\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID;\n\t\t\treleaseID: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel;\n\t\t\treleaseLabel: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual;\n\t\t\tref: RefStringOrThunk;\n\t  }\n);\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>);\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n};\n\n/**\n * Parameters for any client method that use `fetch()`. Only a subset of\n * `fetch()` parameters are exposed.\n */\ntype FetchParams = {\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number;\n};\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: prismicH.LinkResolverFunction;\n\n\t/**\n\t * A fallback URL if the Link Resolver does not return a value.\n\t */\n\tdefaultURL: string;\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string;\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string;\n};\n\n/**\n * Creates a predicate to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst typePredicate = (documentType: string): string =>\n\tpredicate.at(\"document.type\", documentType);\n\n/**\n * Creates a predicate to filter content by document tags. All tags are required\n * on the document.\n *\n * @param documentType - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst everyTagPredicate = (tags: string | string[]): string =>\n\tpredicate.at(\"document.tags\", castArray(tags));\n\n/**\n * Creates a predicate to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param documentType - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst someTagsPredicate = (tags: string | string[]): string =>\n\tpredicate.any(\"document.tags\", castArray(tags));\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @param endpoint - The Prismic REST API V2 endpoint for the repository (use\n *   `prismic.getEndpoint` for the default endpoint).\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient = (\n\t...args: ConstructorParameters<typeof Client>\n): Client => new Client(...args);\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n */\nexport class Client {\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getEndpoint` for the default endpoint).\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t};\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: prismicT.Repository | undefined;\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0;\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as Node.js, the `fetch` option must be provided as part of the\n\t * `options` parameter.\n\t *\n\t * @param endpoint - The Prismic REST API V2 endpoint for the repository (use\n\t *   `prismic.getEndpoint` to get the default endpoint).\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(endpoint: string, options: ClientConfig = {}) {\n\t\tif (\n\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t/\\.prismic\\.io\\/(?!api\\/v2\\/?)/.test(endpoint)\n\t\t) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please use the getEndpoint helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\tthis.endpoint = endpoint;\n\t\tthis.accessToken = options.accessToken;\n\t\tthis.routes = options.routes;\n\t\tthis.defaultParams = options.defaultParams;\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref);\n\t\t}\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch;\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\n\t\tthis.graphqlFetch = this.graphqlFetch.bind(this);\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews();\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req);\n\t * });\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req;\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews();\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false;\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @deprecated Use `get` instead.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.query(\n\t * \tprismic.predicate.at(\"document.type\", \"page\"),\n\t * );\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync query<TDocument extends prismicT.PrismicDocument>(\n\t\tpredicates: NonNullable<BuildQueryURLArgs[\"predicates\"]>,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"predicates\">> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL({ ...params, predicates });\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends prismicT.PrismicDocument>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL(params);\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param params - Parameters to filter, sort, and paginate results. @returns\n\t *   The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends prismicT.PrismicDocument>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst url = await this.buildQueryURL(params);\n\t\tconst result = await this.fetch<prismicT.Query<TDocument>>(url, params);\n\n\t\tconst firstResult = result.results[0];\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult;\n\t\t}\n\n\t\tthrow new PrismicError(\"No documents were returned\", url, undefined);\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by predicates such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no predicates are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends prismicT.PrismicDocument>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params;\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: actualParams.pageSize || MAX_PAGE_SIZE,\n\t\t};\n\n\t\tconst documents: TDocument[] = [];\n\t\tlet latestResult: prismicT.Query<TDocument> | undefined;\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined;\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page });\n\t\t\tdocuments.push(...latestResult.results);\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends prismicT.PrismicDocument>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendPredicates(params, predicate.at(\"document.id\", id)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends prismicT.PrismicDocument>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends prismicT.PrismicDocument>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific Custom Type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable Custom Type which\n\t * allows multiple instances of itself.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the singleton Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the Custom Type, if a matching document exists.\n\t */\n\tasync getSingle<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific Custom Type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the Custom Type.\n\t */\n\tasync getByType<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the Custom Type.\n\t */\n\tasync getAllByType<TDocument extends prismicT.PrismicDocument>(\n\t\tdocumentType: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends prismicT.PrismicDocument>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends prismicT.PrismicDocument>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends prismicT.PrismicDocument>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends prismicT.PrismicDocument>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the tags.\n\t */\n\tasync getBySomeTags<TDocument extends prismicT.PrismicDocument>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends prismicT.PrismicDocument>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<prismicT.Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<prismicT.Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.endpoint);\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t}\n\n\t\treturn await this.fetch<prismicT.Repository>(url.toString(), params);\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst repository = await this.getRepository(params);\n\n\t\treturn repository.refs;\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByID(refs, id);\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByLabel(refs, label);\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findMasterRef(refs);\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(\n\t\tid: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByID(releases, id);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByLabel(releases, label);\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n\n\t\t\treturn await this.fetch<string[]>(tagsForm.action);\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params);\n\n\t\t\treturn repository.tags;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref = params.ref || (await this.getResolvedRefString());\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal })).integrationFieldsRef ||\n\t\t\tundefined;\n\n\t\treturn buildQueryURL(this.endpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t});\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL(\n\t\targs: ResolvePreviewArgs & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID = args.documentID;\n\t\tlet previewToken = args.previewToken;\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search);\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\") || undefined;\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\") || undefined;\n\t\t} else if (this.refState.httpRequest?.query) {\n\t\t\tdocumentID =\n\t\t\t\tdocumentID || (this.refState.httpRequest.query.documentId as string);\n\t\t\tpreviewToken =\n\t\t\t\tpreviewToken || (this.refState.httpRequest.query.token as string);\n\t\t}\n\n\t\tif (documentID != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tsignal: args.signal,\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t});\n\n\t\t\t// We know we have a valid field to resolve since we are using prismicH.documentToLinkField\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\treturn prismicH.asLink(document, args.linkResolver)!;\n\t\t} else {\n\t\t\treturn args.defaultURL;\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent();\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master;\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param id - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param label - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t};\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphqlClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphqlFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphqlFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * });\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t * @experimental\n\t */\n\tasync graphqlFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: RequestInit,\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository();\n\t\tconst ref = await this.getResolvedRefString();\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\t\"Prismic-integration-field-ref\":\n\t\t\t\tcachedRepository.integrationFieldsRef || \"\",\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t};\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {};\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders];\n\t\t\t}\n\t\t}\n\n\t\t// Compress the GraphQL query (if it exists) by removing\n\t\t// whitespace. This is done to optimize the query size and avoid hitting the\n\t\t// upper limit of GET requests (2048 characters).\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t);\n\t\tconst query = url.searchParams.get(\"query\");\n\t\tif (query) {\n\t\t\turl.searchParams.set(\"query\", minifyGraphQLQuery(query));\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response;\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n\t\t\tthis.cachedRepository = await this.getRepository(params);\n\t\t}\n\n\t\treturn this.cachedRepository;\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\t\tconst form = cachedRepository.forms[name];\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\treturn form;\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined = undefined;\n\n\t\t\tif (globalThis.document?.cookie) {\n\t\t\t\tpreviewRef = getCookie(cookie.preview, globalThis.document.cookie);\n\t\t\t} else if (this.refState.httpRequest?.headers?.cookie) {\n\t\t\t\tpreviewRef = getCookie(\n\t\t\t\t\tcookie.preview,\n\t\t\t\t\tthis.refState.httpRequest.headers.cookie,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef;\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\n\t\tconst refModeType = this.refState.mode;\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref;\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)();\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\turl: string,\n\t\t// TODO: Change to `params` when Authorization header support works in browsers with CORS.\n\t\t// _params?: Partial<BuildQueryURLArgs>,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// const accessToken = (params && params.accessToken) || this.accessToken;\n\t\t// const options = accessToken\n\t\t// \t? { headers: { Authorization: `Token ${accessToken}` } }\n\t\t// \t: {};\n\n\t\tconst res = await this.fetchFn(url, {\n\t\t\tsignal: params.signal,\n\t\t});\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tlet json: any;\n\t\ttry {\n\t\t\t// We can assume Prismic REST API responses will have a `application/json`\n\t\t\t// Content Type. If not, this will throw, signaling an invalid response.\n\t\t\tjson = await res.json();\n\t\t} catch {\n\t\t\t// Not Found (this response has an empty body and throws on `.json()`)\n\t\t\t// - Incorrect repository name\n\t\t\tif (res.status === 404) {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\turl,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow new PrismicError(undefined, url, undefined);\n\t\t\t}\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200: {\n\t\t\t\treturn json;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid predicate syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(json.message, url, json);\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\t\"error\" in json ? json.error : json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tjson,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, json);\n\t}\n}\n","// Primary library API.\nexport * from \"./getEndpoint\";\nexport * from \"./getGraphQLEndpoint\";\nexport * from \"./buildQueryURL\";\nexport { createClient, Client } from \"./client\";\n\n// Predicates API.\nimport { predicate } from \"./predicate\";\nexport { predicate };\n/**\n * @deprecated Renamed to `predicate` (without an \"s\").\n */\n// TODO: Remove in v3.\nexport const predicates = predicate;\n/**\n * @deprecated Renamed to `predicate` (lowercase and without an \"s\").\n */\n// TODO: Remove in v3.\nexport const Predicates = predicate;\n\n// Custom errors used by Client.\nexport { PrismicError } from \"./PrismicError\";\nexport { ForbiddenError } from \"./ForbiddenError\";\nexport { ParsingError } from \"./ParsingError\";\nexport { NotFoundError } from \"./NotFoundError\";\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\";\n\n// General types used throughout the project. These are made public to allow users to better type their projects.\nexport type { ClientConfig } from \"./client\";\nexport type {\n\tFetchLike,\n\tHttpRequestLike,\n\tOrdering,\n\tRequestInitLike,\n\tResponseLike,\n\tRoute,\n} from \"./types\";\n"]},"metadata":{},"sourceType":"module"}