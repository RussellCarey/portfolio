{"ast":null,"code":"import _defineProperty from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/r/Desktop/portfolio-final/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n\nvar _RichTextReversedNode;\n\nimport { RichTextNodeType } from '@prismicio/types';\nexport { RichTextNodeType as Element } from '@prismicio/types';\n\nvar uuid = function uuid() {\n  return (++uuid.i).toString();\n};\n\nuuid.i = 0;\n\nvar asTree = function asTree(nodes) {\n  var preparedNodes = prepareNodes(nodes);\n  var children = [];\n\n  for (var i = 0; i < preparedNodes.length; i++) {\n    children.push(nodeToTreeNode(preparedNodes[i]));\n  }\n\n  return {\n    key: uuid(),\n    children: children\n  };\n};\n\nvar createTreeNode = function createTreeNode(node) {\n  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return {\n    key: uuid(),\n    type: node.type,\n    text: \"text\" in node ? node.text : void 0,\n    node: node,\n    children: children\n  };\n};\n\nvar createTextTreeNode = function createTextTreeNode(text) {\n  return createTreeNode({\n    type: RichTextNodeType.span,\n    text: text,\n    spans: []\n  });\n};\n\nvar prepareNodes = function prepareNodes(nodes) {\n  var mutNodes = nodes.slice(0);\n\n  for (var i = 0; i < mutNodes.length; i++) {\n    var node = mutNodes[i];\n\n    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {\n      var items = [node];\n\n      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n        items.push(mutNodes[i + 1]);\n        mutNodes.splice(i, 1);\n      }\n\n      if (node.type === RichTextNodeType.listItem) {\n        mutNodes[i] = {\n          type: RichTextNodeType.list,\n          items: items\n        };\n      } else {\n        mutNodes[i] = {\n          type: RichTextNodeType.oList,\n          items: items\n        };\n      }\n    }\n  }\n\n  return mutNodes;\n};\n\nvar nodeToTreeNode = function nodeToTreeNode(node) {\n  if (\"text\" in node) {\n    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));\n  }\n\n  if (\"items\" in node) {\n    var children = [];\n\n    for (var i = 0; i < node.items.length; i++) {\n      children.push(nodeToTreeNode(node.items[i]));\n    }\n\n    return createTreeNode(node, children);\n  }\n\n  return createTreeNode(node);\n};\n\nvar textNodeSpansToTreeNodeChildren = function textNodeSpansToTreeNodeChildren(spans, node, parentSpan) {\n  if (!spans.length) {\n    return [createTextTreeNode(node.text)];\n  }\n\n  var mutSpans = spans.slice(0);\n  mutSpans.sort(function (a, b) {\n    return a.start - b.start || b.end - a.end;\n  });\n  var children = [];\n\n  for (var i = 0; i < mutSpans.length; i++) {\n    var span = mutSpans[i];\n    var parentSpanStart = parentSpan && parentSpan.start || 0;\n    var spanStart = span.start - parentSpanStart;\n    var spanEnd = span.end - parentSpanStart;\n    var childSpans = [];\n\n    for (var j = i; j < mutSpans.length; j++) {\n      var siblingSpan = mutSpans[j];\n\n      if (siblingSpan !== span && siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n        childSpans.push(siblingSpan);\n        mutSpans.splice(j, 1);\n        j--;\n      }\n    }\n\n    if (i === 0 && spanStart > 0) {\n      children.push(createTextTreeNode(node.text.slice(0, spanStart)));\n    }\n\n    children.push(createTreeNode(span, textNodeSpansToTreeNodeChildren(childSpans, _objectSpread(_objectSpread({}, node), {}, {\n      text: node.text.slice(spanStart, spanEnd)\n    }), span)));\n\n    if (spanEnd < node.text.length) {\n      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));\n    }\n  }\n\n  return children;\n};\n\nvar asText = function asText(richTextField) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n  var result = \"\";\n\n  for (var i = 0; i < richTextField.length; i++) {\n    if (\"text\" in richTextField[i]) {\n      result += (result ? separator : \"\") + richTextField[i].text;\n    }\n  }\n\n  return result;\n};\n\nvar serialize = function serialize(richTextField, serializer) {\n  return serializeTreeNodes(asTree(richTextField).children, serializer);\n};\n\nvar serializeTreeNodes = function serializeTreeNodes(nodes, serializer) {\n  var serializedTreeNodes = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var treeNode = nodes[i];\n    var serializedTreeNode = serializer(treeNode.type, treeNode.node, treeNode.text, serializeTreeNodes(treeNode.children, serializer), treeNode.key);\n\n    if (serializedTreeNode != null) {\n      serializedTreeNodes.push(serializedTreeNode);\n    }\n  }\n\n  return serializedTreeNodes;\n};\n\nvar RichTextReversedNodeType = (_RichTextReversedNode = {}, _defineProperty(_RichTextReversedNode, RichTextNodeType.listItem, \"listItem\"), _defineProperty(_RichTextReversedNode, RichTextNodeType.oListItem, \"oListItem\"), _defineProperty(_RichTextReversedNode, RichTextNodeType.list, \"list\"), _defineProperty(_RichTextReversedNode, RichTextNodeType.oList, \"oList\"), _RichTextReversedNode);\n\nvar wrapMapSerializer = function wrapMapSerializer(mapSerializer) {\n  return function (type, node, text, children, key) {\n    var tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];\n\n    if (tagSerializer) {\n      return tagSerializer({\n        type: type,\n        node: node,\n        text: text,\n        children: children,\n        key: key\n      });\n    }\n  };\n};\n\nvar composeSerializers = function composeSerializers() {\n  for (var _len = arguments.length, serializers = new Array(_len), _key = 0; _key < _len; _key++) {\n    serializers[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var i = 0; i < serializers.length; i++) {\n      var serializer = serializers[i];\n\n      if (serializer) {\n        var res = serializer.apply(void 0, arguments);\n\n        if (res != null) {\n          return res;\n        }\n      }\n    }\n  };\n};\n\nexport { asText, asTree, composeSerializers, serialize, wrapMapSerializer };","map":{"version":3,"mappings":"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","names":["uuid","i","toString","asTree","nodes","preparedNodes","prepareNodes","children","length","push","nodeToTreeNode","key","createTreeNode","node","type","text","createTextTreeNode","RichTextNodeType","span","spans","mutNodes","slice","listItem","oListItem","items","splice","list","oList","textNodeSpansToTreeNodeChildren","parentSpan","mutSpans","sort","a","b","start","end","parentSpanStart","spanStart","spanEnd","childSpans","j","siblingSpan","asText","richTextField","separator","result","serialize","serializer","serializeTreeNodes","serializedTreeNodes","treeNode","serializedTreeNode","RichTextReversedNodeType","wrapMapSerializer","mapSerializer","tagSerializer","composeSerializers","serializers","res"],"sources":["/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/asTree.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/asText.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/serialize.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/types.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/wrapMapSerializer.ts","/Users/r/Desktop/portfolio-final/client/node_modules/@prismicio/richtext/src/composeSerializers.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (\n\t\t\t\tsiblingSpan !== span &&\n\t\t\t\tsiblingSpan.start >= span.start &&\n\t\t\t\tsiblingSpan.end <= span.end\n\t\t\t) {\n\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspan,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext: node.text.slice(spanStart, spanEnd),\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n","import { RichTextField, RTTextNode } from \"@prismicio/types\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n","import { RichTextField } from \"@prismicio/types\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the serializer\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n","import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTEmbedNode,\n\tRTEmNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n} from \"@prismicio/types\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n * @typeParam ReturnType - Return type of the map serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n","import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the map serializer\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n","import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of serializers\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"module"}