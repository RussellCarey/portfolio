{"ast":null,"code":"import { RichTextNodeType } from '@prismicio/types';\nexport { RichTextNodeType as Element } from '@prismicio/types';\n\nconst uuid = () => {\n  return (++uuid.i).toString();\n};\n\nuuid.i = 0;\n\nconst asTree = nodes => {\n  const preparedNodes = prepareNodes(nodes);\n  const children = [];\n\n  for (let i = 0; i < preparedNodes.length; i++) {\n    children.push(nodeToTreeNode(preparedNodes[i]));\n  }\n\n  return {\n    key: uuid(),\n    children\n  };\n};\n\nconst createTreeNode = function (node) {\n  let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return {\n    key: uuid(),\n    type: node.type,\n    text: \"text\" in node ? node.text : void 0,\n    node,\n    children\n  };\n};\n\nconst createTextTreeNode = text => {\n  return createTreeNode({\n    type: RichTextNodeType.span,\n    text,\n    spans: []\n  });\n};\n\nconst prepareNodes = nodes => {\n  const mutNodes = nodes.slice(0);\n\n  for (let i = 0; i < mutNodes.length; i++) {\n    const node = mutNodes[i];\n\n    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {\n      const items = [node];\n\n      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n        items.push(mutNodes[i + 1]);\n        mutNodes.splice(i, 1);\n      }\n\n      if (node.type === RichTextNodeType.listItem) {\n        mutNodes[i] = {\n          type: RichTextNodeType.list,\n          items\n        };\n      } else {\n        mutNodes[i] = {\n          type: RichTextNodeType.oList,\n          items\n        };\n      }\n    }\n  }\n\n  return mutNodes;\n};\n\nconst nodeToTreeNode = node => {\n  if (\"text\" in node) {\n    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));\n  }\n\n  if (\"items\" in node) {\n    const children = [];\n\n    for (let i = 0; i < node.items.length; i++) {\n      children.push(nodeToTreeNode(node.items[i]));\n    }\n\n    return createTreeNode(node, children);\n  }\n\n  return createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (spans, node, parentSpan) => {\n  if (!spans.length) {\n    return [createTextTreeNode(node.text)];\n  }\n\n  const mutSpans = spans.slice(0);\n  mutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n  const children = [];\n\n  for (let i = 0; i < mutSpans.length; i++) {\n    const span = mutSpans[i];\n    const parentSpanStart = parentSpan && parentSpan.start || 0;\n    const spanStart = span.start - parentSpanStart;\n    const spanEnd = span.end - parentSpanStart;\n    const childSpans = [];\n\n    for (let j = i; j < mutSpans.length; j++) {\n      const siblingSpan = mutSpans[j];\n\n      if (siblingSpan !== span && siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n        childSpans.push(siblingSpan);\n        mutSpans.splice(j, 1);\n        j--;\n      }\n    }\n\n    if (i === 0 && spanStart > 0) {\n      children.push(createTextTreeNode(node.text.slice(0, spanStart)));\n    }\n\n    children.push(createTreeNode(span, textNodeSpansToTreeNodeChildren(childSpans, { ...node,\n      text: node.text.slice(spanStart, spanEnd)\n    }, span)));\n\n    if (spanEnd < node.text.length) {\n      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));\n    }\n  }\n\n  return children;\n};\n\nconst asText = function (richTextField) {\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n  let result = \"\";\n\n  for (let i = 0; i < richTextField.length; i++) {\n    if (\"text\" in richTextField[i]) {\n      result += (result ? separator : \"\") + richTextField[i].text;\n    }\n  }\n\n  return result;\n};\n\nconst serialize = (richTextField, serializer) => {\n  return serializeTreeNodes(asTree(richTextField).children, serializer);\n};\n\nconst serializeTreeNodes = (nodes, serializer) => {\n  const serializedTreeNodes = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const treeNode = nodes[i];\n    const serializedTreeNode = serializer(treeNode.type, treeNode.node, treeNode.text, serializeTreeNodes(treeNode.children, serializer), treeNode.key);\n\n    if (serializedTreeNode != null) {\n      serializedTreeNodes.push(serializedTreeNode);\n    }\n  }\n\n  return serializedTreeNodes;\n};\n\nconst RichTextReversedNodeType = {\n  [RichTextNodeType.listItem]: \"listItem\",\n  [RichTextNodeType.oListItem]: \"oListItem\",\n  [RichTextNodeType.list]: \"list\",\n  [RichTextNodeType.oList]: \"oList\"\n};\n\nconst wrapMapSerializer = mapSerializer => {\n  return (type, node, text, children, key) => {\n    const tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];\n\n    if (tagSerializer) {\n      return tagSerializer({\n        type,\n        node,\n        text,\n        children,\n        key\n      });\n    }\n  };\n};\n\nconst composeSerializers = function () {\n  for (var _len = arguments.length, serializers = new Array(_len), _key = 0; _key < _len; _key++) {\n    serializers[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (let i = 0; i < serializers.length; i++) {\n      const serializer = serializers[i];\n\n      if (serializer) {\n        const res = serializer(...arguments);\n\n        if (res != null) {\n          return res;\n        }\n      }\n    }\n  };\n};\n\nexport { asText, asTree, composeSerializers, serialize, wrapMapSerializer };","map":{"version":3,"mappings":"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","names":["uuid","i","toString","asTree","nodes","preparedNodes","prepareNodes","children","length","push","nodeToTreeNode","key","createTreeNode","node","type","text","createTextTreeNode","RichTextNodeType","span","spans","mutNodes","slice","listItem","oListItem","items","splice","list","oList","textNodeSpansToTreeNodeChildren","parentSpan","mutSpans","sort","a","b","start","end","parentSpanStart","spanStart","spanEnd","childSpans","j","siblingSpan","asText","richTextField","separator","result","serialize","serializer","serializeTreeNodes","serializedTreeNodes","treeNode","serializedTreeNode","RichTextReversedNodeType","wrapMapSerializer","mapSerializer","tagSerializer","composeSerializers","serializers","res"],"sources":["/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/asTree.ts","/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/asText.ts","/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/serialize.ts","/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/types.ts","/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/wrapMapSerializer.ts","/Users/r/Desktop/portfolio-final/node_modules/@prismicio/richtext/src/composeSerializers.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (\n\t\t\t\tsiblingSpan !== span &&\n\t\t\t\tsiblingSpan.start >= span.start &&\n\t\t\t\tsiblingSpan.end <= span.end\n\t\t\t) {\n\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspan,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext: node.text.slice(spanStart, spanEnd),\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n","import { RichTextField, RTTextNode } from \"@prismicio/types\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n","import { RichTextField } from \"@prismicio/types\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the serializer\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n","import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTEmbedNode,\n\tRTEmNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n} from \"@prismicio/types\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n * @typeParam ReturnType - Return type of the map serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n","import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the map serializer\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n","import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of serializers\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"module"}